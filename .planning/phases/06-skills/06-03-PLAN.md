---
phase: 06-skills
plan: 03
status: ready
estimated_tasks: 4
---

# Plan 06-03: Edit Modal and Tool Binding

## Objective

Build the edit modal for draft changes and integrate skills with the decision node through proper tool binding. The edit modal allows users to modify draft fields directly, while tool binding establishes the "Decision node decides when, skills handle how" pattern.

## Execution Context

- Base: src/slack/handlers.py (existing handle_reject_draft opens modal)
- Base: src/skills/ (ask_user, preview_ticket from 06-01, 06-02)
- Base: src/graph/nodes/decision.py (DecisionResult determines action)
- Reference: 06-CONTEXT.md (modal specs, skill architecture)

## Context

From 06-CONTEXT.md:
### Edit Modal Specifics
- All draft fields editable: title, problem, solution, AC, constraints, risks
- Client-side validation only (Slack modal validates required fields)
- After submit: replace preview message with updated values, keep buttons

### Skill Architecture
- Skills are async functions that return results (not graph nodes)
- Slack client passed as parameter (explicit dependency injection)
- Decision node decides "when" to call skills, skills handle "how"
- Hybrid tool access: LLM can request tools but Decision node controls execution

Current state:
- `handle_reject_draft()` posts "Tell me what needs to be changed" (no modal yet)
- Decision node returns action but handlers do the Slack posting directly
- No formal tool binding between decision node and skills

## Tasks

### Task 1: Create edit modal view builder

Create `src/slack/modals.py` with:
- `build_edit_draft_modal()` function that builds Slack modal view
- All draft fields as inputs:
  - Title: plain_text_input (required)
  - Problem: plain_text_input multiline (required)
  - Proposed Solution: plain_text_input multiline (optional)
  - Acceptance Criteria: plain_text_input multiline (one per line)
  - Constraints: plain_text_input multiline (optional, key=value format)
  - Risks: plain_text_input multiline (optional)
- Pre-fill with current draft values
- Private metadata includes: session_id, draft_hash, preview_message_ts

Modal structure:
```python
{
    "type": "modal",
    "callback_id": "edit_draft_modal",
    "title": {"type": "plain_text", "text": "Edit Draft"},
    "submit": {"type": "plain_text", "text": "Update"},
    "close": {"type": "plain_text", "text": "Cancel"},
    "private_metadata": json.dumps({...}),
    "blocks": [...]
}
```

Files:
- Create: src/slack/modals.py

Checkpoint: `python -c "from src.slack.modals import build_edit_draft_modal; print('ok')"`

### Task 2: Implement modal open and submit handlers

Update handlers to:
- `handle_reject_draft()`: open edit modal instead of posting message
- Add `handle_edit_draft_submit()`: process modal submission

Modal submit flow:
1. Parse submitted values from view state
2. Parse private_metadata for session info
3. Update draft in runner state:
   - Parse AC as list (split by newlines)
   - Parse constraints as key=value pairs
4. Get updated draft and compute new hash
5. Update original preview message with new draft (replace, keep buttons)
6. Post confirmation: "Draft updated. Please review the changes above."

Files:
- Edit: src/slack/handlers.py (handle_reject_draft, add handle_edit_draft_submit)
- Edit: src/slack/app.py (register view submission handler)

Checkpoint: Modal opens and submits without error

### Task 3: Create skill dispatcher

Create `src/skills/dispatcher.py` to formalize tool binding:
- `SkillDispatcher` class that:
  - Takes Slack client and session identity as constructor args
  - Has methods: `ask_user()`, `preview_ticket()`
  - Routes DecisionResult.action to appropriate skill
  - Returns skill result for handler to act on

```python
class SkillDispatcher:
    def __init__(self, client: WebClient, identity: SessionIdentity):
        self.client = client
        self.identity = identity

    async def dispatch(self, decision: DecisionResult, draft: TicketDraft) -> dict:
        if decision.action == "ask":
            return await self.ask_user(decision.questions)
        elif decision.action == "preview":
            return await self.preview_ticket(draft)
        elif decision.action == "ready_to_create":
            return {"action": "ready", "draft": draft}
```

Pattern: Decision node decides "what" (ask/preview/ready), dispatcher handles "how".

Files:
- Create: src/skills/dispatcher.py
- Edit: src/skills/__init__.py (export SkillDispatcher)

Checkpoint: `python -c "from src.skills.dispatcher import SkillDispatcher; print('ok')"`

### Task 4: Integrate dispatcher with handlers

Refactor handlers to use SkillDispatcher:
- `_process_mention()` and `_process_thread_message()`:
  - Create dispatcher with client and identity
  - Call `dispatcher.dispatch(result, draft)`
  - Handle skill result uniformly

This establishes clean separation:
- Runner: manages graph execution, returns DecisionResult
- Dispatcher: calls appropriate skill based on decision
- Handler: orchestrates and handles Slack-specific response

Files:
- Edit: src/slack/handlers.py (use dispatcher)

Checkpoint: `python -c "from src.slack.handlers import handle_app_mention; print('ok')"`

## Verification

```bash
# All imports work
python -c "
from src.slack.modals import build_edit_draft_modal
from src.skills.dispatcher import SkillDispatcher
print('all imports ok')
"

# Modal builder produces valid structure
python -c "
from src.slack.modals import build_edit_draft_modal
from src.schemas.draft import TicketDraft
draft = TicketDraft(title='Test', problem='Problem')
modal = build_edit_draft_modal(draft, 'session123', 'hash123', 'msg_ts')
assert modal['type'] == 'modal'
assert modal['callback_id'] == 'edit_draft_modal'
print('modal ok')
"

# Dispatcher routes correctly
python -c "
from src.skills.dispatcher import SkillDispatcher
from src.graph.nodes.decision import DecisionResult
# Verify class structure
import inspect
assert 'dispatch' in dir(SkillDispatcher)
print('dispatcher ok')
"
```

## Success Criteria

- Edit modal opens with pre-filled draft values
- Modal submission updates draft and replaces preview message
- SkillDispatcher routes decisions to appropriate skills
- Handlers use dispatcher for clean separation of concerns
- "Decision decides when, skills handle how" pattern established

## Output

Files created/modified:
- src/slack/modals.py (new)
- src/skills/dispatcher.py (new)
- src/skills/__init__.py (updated)
- src/slack/handlers.py (updated)
- src/slack/app.py (updated)
