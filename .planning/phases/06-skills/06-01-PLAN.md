---
phase: 06-skills
plan: 01
status: ready
estimated_tasks: 5
---

# Plan 06-01: ask_user Skill

## Objective

Build the `ask_user` skill that posts questions to Slack threads and handles the interrupt/resume pattern. This is the core "aliveness" mechanism - the agent can pause waiting for input and resume when the user responds.

## Execution Context

- Base: src/slack/handlers.py (existing handler structure)
- Base: src/graph/runner.py (interrupt/resume via GraphRunner)
- Base: src/graph/nodes/decision.py (DecisionResult with questions[])
- Reference: Phase 5 decisions (05-03: smart batching, max 3 questions)

## Context

From 06-CONTEXT.md:
- Input: `channel`, `thread_ts`, `questions[]`, `context` (why asking), `expected_fields[]` (optional)
- Output: `message_ts`, `question_id` (UUID), `status="asked"`
- Both modes: plain text default, optional inline buttons for Yes/No style questions
- Semantic matching: LLM figures out which part of response answers which question
- Re-ask limit: 2 times max, then proceed with what we have
- Skills are async functions with explicit parameters (not graph nodes)

Current state (from Phase 5):
- handlers.py `_process_mention` already formats questions as bullet list
- DecisionResult.questions contains prioritized, batched questions (max 3)
- Graph interrupts at `AWAITING_USER` phase

## Tasks

### Task 1: Create skill module structure

Create `src/skills/__init__.py` and `src/skills/ask_user.py` with:
- `QuestionSet` Pydantic model: `question_id`, `questions[]`, `expected_fields[]`, `asked_at`, `re_ask_count`
- `AskResult` Pydantic model: `message_ts`, `question_id`, `status` enum (asked/answered/timed_out)
- `ask_user()` async function signature

Files:
- Create: src/skills/__init__.py
- Create: src/skills/ask_user.py

Checkpoint: `python -c "from src.skills.ask_user import ask_user, QuestionSet; print('ok')"`

### Task 2: Implement ask_user skill

Implement the core skill logic:
- Posts questions to thread as formatted message
- Optionally adds inline buttons for Yes/No questions (detected by question content)
- Generates `question_id` (UUID) for tracking
- Stores `QuestionSet` in state for later matching
- Returns `AskResult` with `message_ts`

Button detection heuristic:
- Questions starting with "Is ", "Are ", "Do ", "Does ", "Should ", "Will " get Yes/No buttons
- Other questions get plain text input

Files:
- Edit: src/skills/ask_user.py

Checkpoint: `python -c "from src.skills.ask_user import ask_user; print('skill ok')"`

### Task 3: Add question tracking to state

Add question tracking fields to AgentState:
- `pending_questions: QuestionSet | None` - current unanswered questions
- `question_history: list[QuestionSet]` - for re-ask tracking

Update runner to:
- Store `QuestionSet` when `ask_user` returns
- Clear `pending_questions` when user responds

Files:
- Edit: src/schemas/state.py (add pending_questions, question_history)
- Edit: src/graph/runner.py (track questions)

Checkpoint: `python -c "from src.schemas.state import AgentState; print('state ok')"`

### Task 4: Implement semantic answer matching

Create answer matching logic:
- When user responds, correlate with `pending_questions`
- Use LLM to match response parts to questions (semantic matching)
- Extract structured answers per question

Add `src/skills/answer_matcher.py`:
- `AnswerMatch` model: `question`, `answer`, `confidence`, `source_text`
- `match_answers()` function: takes user message + QuestionSet, returns matches

Files:
- Create: src/skills/answer_matcher.py
- Edit: src/graph/nodes/extraction.py (use answer matcher for better extraction)

Checkpoint: `python -c "from src.skills.answer_matcher import match_answers; print('matcher ok')"`

### Task 5: Implement re-ask logic

Add re-ask handling:
- Track `re_ask_count` per question
- If response doesn't answer all questions, re-ask missing (max 2 times)
- After 2 re-asks, proceed with what we have

Update decision node to:
- Check for unanswered questions from previous ask
- Increment re_ask_count
- After max re-asks, move forward with partial info

Files:
- Edit: src/graph/nodes/decision.py (re-ask logic)
- Edit: src/skills/ask_user.py (re-ask support)

Checkpoint: `python -c "from src.graph.nodes.decision import decision_node; print('decision ok')"`

## Verification

```bash
# All imports work
python -c "
from src.skills import ask_user
from src.skills.ask_user import ask_user, QuestionSet, AskResult
from src.skills.answer_matcher import match_answers, AnswerMatch
print('all imports ok')
"

# State has new fields
python -c "
from src.schemas.state import AgentState
# TypedDict doesn't enforce at runtime, but presence check works
print('state ok')
"
```

## Success Criteria

- `ask_user()` skill posts formatted questions to Slack thread
- Yes/No questions get inline buttons automatically
- `question_id` tracks which questions were asked
- Semantic matching correlates user responses to questions
- Re-ask limit (2x) prevents infinite loops
- Graph interrupt/resume works correctly with ask flow

## Output

Files created/modified:
- src/skills/__init__.py (new)
- src/skills/ask_user.py (new)
- src/skills/answer_matcher.py (new)
- src/schemas/state.py (updated)
- src/graph/runner.py (updated)
- src/graph/nodes/decision.py (updated)
- src/graph/nodes/extraction.py (updated)
