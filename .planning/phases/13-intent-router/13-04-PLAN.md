---
phase: 13-intent-router
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - src/slack/handlers.py
  - src/graph/intent.py
  - tests/test_intent_router.py
autonomous: true
---

<objective>
Implement Review â†’ Ticket transition with scope gate, and add regression tests for intent classification.

Purpose: After review, user can say "create a ticket for this" to transition seamlessly. Tests ensure intent classification reliability.
Output: Scope gate UI, transition handler, regression test suite for intent patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-intent-router/13-CONTEXT.md
@.planning/phases/13-intent-router/13-02-SUMMARY.md
@.planning/phases/13-intent-router/13-03-SUMMARY.md

Relevant source files:
@src/slack/handlers.py
@src/graph/intent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add "Turn into ticket" button to review responses</name>
  <files>src/slack/handlers.py</files>
  <action>
Update the "review" action handling to include a transition button:

```python
elif action == "review":
    review_msg = decision_result.get("message", "")
    persona = decision_result.get("persona", "")
    topic = decision_result.get("topic", "")

    if persona:
        prefix = f"*{persona.title()} Review:*\n\n"
    else:
        prefix = ""

    # Build blocks with review content and action button
    blocks = [
        {
            "type": "section",
            "text": {"type": "mrkdwn", "text": prefix + review_msg}
        },
        {
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Turn into Jira ticket"},
                    "action_id": "review_to_ticket",
                    "value": json.dumps({
                        "review_text": review_msg[:2000],  # Slack limit
                        "topic": topic,
                        "persona": persona,
                    }),
                    "style": "primary",
                }
            ]
        }
    ]

    await client.chat_postMessage(
        channel=channel_id,
        thread_ts=thread_ts,
        blocks=blocks,
        text=prefix + review_msg,  # Fallback
    )
```

Also add the action handler for `review_to_ticket`:

```python
@app.action("review_to_ticket")
def handle_review_to_ticket(ack, body, client, logger):
    ack()
    # Extract context from button value
    value = json.loads(body["actions"][0]["value"])
    thread_ts = body["message"].get("thread_ts") or body["message"]["ts"]
    channel_id = body["channel"]["id"]
    user_id = body["user"]["id"]

    # Show scope gate modal
    client.views_open(
        trigger_id=body["trigger_id"],
        view={
            "type": "modal",
            "callback_id": "review_scope_gate",
            "private_metadata": json.dumps({
                "thread_ts": thread_ts,
                "channel_id": channel_id,
                "review_text": value.get("review_text", ""),
                "topic": value.get("topic", ""),
            }),
            "title": {"type": "plain_text", "text": "Create Ticket"},
            "submit": {"type": "plain_text", "text": "Create Draft"},
            "blocks": [
                {
                    "type": "section",
                    "text": {"type": "mrkdwn", "text": "*What should become a ticket?*"}
                },
                {
                    "type": "input",
                    "block_id": "scope_select",
                    "element": {
                        "type": "radio_buttons",
                        "action_id": "scope_choice",
                        "options": [
                            {"text": {"type": "plain_text", "text": "Final decision only"}, "value": "decision"},
                            {"text": {"type": "plain_text", "text": "Full review/proposal"}, "value": "full"},
                            {"text": {"type": "plain_text", "text": "Specific part (I'll describe)"}, "value": "custom"},
                        ],
                        "initial_option": {"text": {"type": "plain_text", "text": "Full review/proposal"}, "value": "full"},
                    },
                    "label": {"type": "plain_text", "text": "Scope"},
                },
                {
                    "type": "input",
                    "block_id": "custom_scope",
                    "optional": True,
                    "element": {
                        "type": "plain_text_input",
                        "action_id": "custom_input",
                        "placeholder": {"type": "plain_text", "text": "Describe what to include..."},
                    },
                    "label": {"type": "plain_text", "text": "Custom scope (if selected above)"},
                }
            ]
        }
    )
```

Add modal submission handler:

```python
@app.view("review_scope_gate")
def handle_scope_gate_submit(ack, body, client, view, logger):
    ack()
    values = view["state"]["values"]
    metadata = json.loads(view["private_metadata"])

    scope = values["scope_select"]["scope_choice"]["selected_option"]["value"]
    custom_text = values.get("custom_scope", {}).get("custom_input", {}).get("value", "")

    # Post message to trigger ticket flow with context
    channel_id = metadata["channel_id"]
    thread_ts = metadata["thread_ts"]
    review_text = metadata.get("review_text", "")
    topic = metadata.get("topic", "")

    # Build context message for extraction
    if scope == "decision":
        context_msg = f"Create a ticket for the final decision from this review: {topic}"
    elif scope == "full":
        context_msg = f"Create a ticket based on this full review:\n\n{review_text[:1500]}"
    else:
        context_msg = f"Create a ticket for: {custom_text}"

    # Post as user message to continue in thread
    client.chat_postMessage(
        channel=channel_id,
        thread_ts=thread_ts,
        text=f"<@{client.auth_test()['user_id']}> {context_msg}",
    )
    # This will trigger the normal message handler, which will classify as TICKET
    # and proceed with extraction using the review context
```
  </action>
  <verify>`python -m py_compile src/slack/handlers.py`</verify>
  <done>Review responses include "Turn into ticket" button, scope gate modal works, submission triggers ticket flow</done>
</task>

<task type="auto">
  <name>Task 2: Create regression test suite for intent classification</name>
  <files>tests/test_intent_router.py</files>
  <action>
Create `tests/test_intent_router.py` with test cases from 13-CONTEXT.md DoD (10-20 phrases per flow):

```python
"""Regression tests for intent classification.

Tests explicit pattern detection and overall classification accuracy.
"""
import pytest
from src.graph.intent import classify_intent_patterns, IntentType


class TestExplicitPatterns:
    """Test explicit override detection (no LLM)."""

    @pytest.mark.parametrize("message,expected_intent", [
        # TICKET patterns
        ("create a ticket for this feature", IntentType.TICKET),
        ("draft a jira story for user auth", IntentType.TICKET),
        ("make a ticket", IntentType.TICKET),
        ("I need a Jira issue for this", IntentType.TICKET),
        ("/maro ticket", IntentType.TICKET),
        ("jira story for notifications", IntentType.TICKET),

        # REVIEW patterns
        ("propose an architecture for this", IntentType.REVIEW),
        ("review this as security", IntentType.REVIEW),
        ("review as architect", IntentType.REVIEW),
        ("analyze the risks", IntentType.REVIEW),
        ("what are the risks here", IntentType.REVIEW),
        ("evaluate this approach", IntentType.REVIEW),
        ("/maro review", IntentType.REVIEW),
        ("don't create a ticket, just review", IntentType.REVIEW),
        ("assess this design", IntentType.REVIEW),
        ("think through this with me", IntentType.REVIEW),

        # DISCUSSION patterns (simple, no clear action)
        ("hi", IntentType.DISCUSSION),
        ("hello", IntentType.DISCUSSION),
        ("hey maro", IntentType.DISCUSSION),
        ("what can you do?", IntentType.DISCUSSION),
        ("thanks!", IntentType.DISCUSSION),
    ])
    def test_explicit_pattern(self, message, expected_intent):
        """Explicit patterns should be detected without LLM."""
        result = classify_intent_patterns(message)
        if result is not None:
            assert result.intent == expected_intent
        # None result means LLM needed - acceptable for some cases


class TestPersonaHints:
    """Test persona hint extraction from messages."""

    @pytest.mark.parametrize("message,expected_persona", [
        ("review as security", "security"),
        ("review as architect", "architect"),
        ("review as pm", "pm"),
        ("analyze this from security perspective", "security"),
        ("what would an architect say", "architect"),
    ])
    def test_persona_hint(self, message, expected_persona):
        result = classify_intent_patterns(message)
        if result is not None:
            assert result.persona_hint == expected_persona


class TestConfidenceScores:
    """Test confidence scores for explicit vs ambiguous patterns."""

    def test_explicit_pattern_high_confidence(self):
        """Explicit patterns should have confidence 1.0."""
        result = classify_intent_patterns("create a ticket for this")
        assert result is not None
        assert result.confidence == 1.0

    def test_explicit_override_high_confidence(self):
        """Explicit overrides should have confidence 1.0."""
        result = classify_intent_patterns("don't create a ticket")
        assert result is not None
        assert result.confidence == 1.0
```

This tests the pattern-matching layer. LLM classification testing would require mocking.
  </action>
  <verify>`python -m pytest tests/test_intent_router.py -v --collect-only` lists test cases</verify>
  <done>Regression tests cover TICKET, REVIEW, DISCUSSION patterns with 20+ test cases</done>
</task>

<task type="auto">
  <name>Task 3: Export classify_intent_patterns for testing</name>
  <files>src/graph/intent.py</files>
  <action>
Refactor intent.py to expose pattern-matching function for testing:

1. Extract pattern matching into separate function:
```python
def classify_intent_patterns(message: str) -> IntentResult | None:
    """Classify intent using explicit patterns only.

    Returns IntentResult if explicit pattern found, None if LLM needed.
    This function is pure/deterministic for testing.
    """
    message_lower = message.lower().strip()

    # Check explicit TICKET patterns
    ticket_patterns = [
        "create a ticket", "draft a ticket", "make a ticket",
        "jira story", "jira issue", "jira ticket",
        "/maro ticket",
    ]
    for pattern in ticket_patterns:
        if pattern in message_lower:
            return IntentResult(
                intent=IntentType.TICKET,
                confidence=1.0,
                reasons=[f"explicit: {pattern}"],
            )

    # Check explicit REVIEW patterns
    review_patterns = [
        "propose architecture", "propose an architecture",
        "review as", "analyze", "risks", "evaluate", "assess",
        "/maro review", "don't create a ticket", "think through",
    ]
    persona_hint = None
    for pattern in review_patterns:
        if pattern in message_lower:
            # Extract persona hint if present
            if "as security" in message_lower:
                persona_hint = "security"
            elif "as architect" in message_lower:
                persona_hint = "architect"
            elif "as pm" in message_lower:
                persona_hint = "pm"

            return IntentResult(
                intent=IntentType.REVIEW,
                confidence=1.0,
                persona_hint=persona_hint,
                reasons=[f"explicit: {pattern}"],
            )

    # Check DISCUSSION patterns (greetings)
    discussion_patterns = ["hi", "hello", "hey", "thanks", "thank you", "what can you do"]
    for pattern in discussion_patterns:
        if message_lower == pattern or message_lower.startswith(pattern + " ") or message_lower.rstrip("!?") == pattern:
            return IntentResult(
                intent=IntentType.DISCUSSION,
                confidence=1.0,
                reasons=[f"greeting: {pattern}"],
            )

    return None  # Need LLM for classification
```

2. Update intent_router_node to use this function:
```python
async def intent_router_node(state: AgentState) -> dict:
    # ... get message ...

    # Try pattern matching first
    result = classify_intent_patterns(message_text)

    if result is None:
        # Fall back to LLM classification
        result = await _llm_classify_intent(message_text)

    logger.info(
        "Intent classified",
        extra={
            "intent": result.intent.value,
            "confidence": result.confidence,
            "reasons": result.reasons,
        }
    )

    return {"intent_result": result.model_dump()}
```

This makes the pattern matching testable without mocking LLM.
  </action>
  <verify>`python -m py_compile src/graph/intent.py` passes</verify>
  <done>classify_intent_patterns function exported and testable, intent_router_node uses it</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile src/slack/handlers.py` passes
- [ ] `python -m py_compile src/graph/intent.py` passes
- [ ] `python -m pytest tests/test_intent_router.py -v` runs tests
- [ ] Tests cover 20+ phrase patterns across all three intents
</verification>

<success_criteria>

- Review responses include "Turn into ticket" button
- Scope gate modal asks what to include in ticket
- Modal submission triggers ticket flow with review context
- Regression tests exist for 20+ intent classification phrases
- Pattern matching is deterministic and testable
- Tests pass for explicit patterns (TICKET, REVIEW, DISCUSSION)
</success_criteria>

<output>
After completion, create `.planning/phases/13-intent-router/13-04-SUMMARY.md`
</output>
