---
phase: 11-conversation-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/slack/history.py, src/slack/__init__.py]
autonomous: true
---

<objective>
Create conversation history fetching service for Slack channels and threads.

Purpose: Provide reusable functions to fetch recent channel messages and thread replies using Slack API. This is the foundation for context injection.
Output: `src/slack/history.py` with `fetch_channel_history()` and `fetch_thread_history()` functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-conversation-history/11-RESEARCH.md
@.planning/phases/11-conversation-history/11-CONTEXT.md

Relevant source files:
@src/slack/bot.py (WebClient initialization)
@src/slack/handlers/main.py (current message handling)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create history fetching functions</name>
  <files>src/slack/history.py</files>
  <action>
Create `src/slack/history.py` with two core functions:

1. `fetch_channel_history(client: WebClient, channel_id: str, before_ts: str | None = None, limit: int = 20) -> list[dict]`
   - Call `client.conversations_history(channel=channel_id, latest=before_ts, inclusive=False, limit=limit)`
   - Handle `SlackApiError` gracefully - log and return empty list on rate limit
   - Return list of message dicts from response

2. `fetch_thread_history(client: WebClient, channel_id: str, thread_ts: str) -> list[dict]`
   - Call `client.conversations_replies(channel=channel_id, ts=thread_ts, limit=200)`
   - Handle `SlackApiError` gracefully
   - Return list of message dicts from response

Both functions should:
- Use typing annotations
- Have docstrings explaining parameters
- Log errors with `logging.getLogger(__name__)`
- NOT raise exceptions - return empty list on failure

From research (11-RESEARCH.md):
- We have Tier 3 rate limits (internal app) so ~50 req/min is fine
- Thread limit of 200 is sufficient (threads are typically compact)
- Channel limit of 20 is good default for on-demand fetch
  </action>
  <verify>python -c "from src.slack.history import fetch_channel_history, fetch_thread_history; print('Import OK')"</verify>
  <done>Both functions exist and import without errors</done>
</task>

<task type="auto">
  <name>Task 2: Add message formatting utility</name>
  <files>src/slack/history.py</files>
  <action>
Add to `src/slack/history.py`:

3. `format_messages_for_context(messages: list[dict], include_timestamps: bool = False) -> str`
   - Format Slack messages for LLM context injection
   - Each line: `[{user}] {text}` or `[{user} at {ts}] {text}` if include_timestamps
   - Handle missing user/text gracefully (use "unknown" / skip empty)
   - Return joined string with newlines

4. `ConversationContext` dataclass:
```python
@dataclass
class ConversationContext:
    messages: list[dict]  # Raw Slack messages
    summary: str | None = None  # Compressed narrative (None until summarized)
    last_updated_at: datetime | None = None

    def to_prompt_context(self) -> str:
        """Format for LLM prompt injection."""
        parts = []
        if self.summary:
            parts.append(f"## Conversation Summary\n{self.summary}")
        if self.messages:
            formatted = format_messages_for_context(self.messages)
            parts.append(f"## Recent Messages\n{formatted}")
        return "\n\n".join(parts)
```

This follows the two-layer pattern from research.
  </action>
  <verify>python -c "from src.slack.history import ConversationContext, format_messages_for_context; print('Import OK')"</verify>
  <done>ConversationContext class and format function exist</done>
</task>

<task type="auto">
  <name>Task 3: Export from package</name>
  <files>src/slack/__init__.py</files>
  <action>
Add exports to `src/slack/__init__.py`:
- `fetch_channel_history`
- `fetch_thread_history`
- `format_messages_for_context`
- `ConversationContext`

From `src.slack.history`.
  </action>
  <verify>python -c "from src.slack import fetch_channel_history, ConversationContext; print('Export OK')"</verify>
  <done>Functions accessible from src.slack package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.slack.history import fetch_channel_history, fetch_thread_history, format_messages_for_context, ConversationContext"` succeeds
- [ ] `python -c "from src.slack import fetch_channel_history, ConversationContext"` succeeds
- [ ] No syntax errors in new file
</verification>

<success_criteria>
- All tasks completed
- History fetching service is importable
- ConversationContext dataclass provides two-layer context formatting
- Functions handle errors gracefully (no uncaught exceptions)
</success_criteria>

<output>
After completion, create `.planning/phases/11-conversation-history/11-01-SUMMARY.md`
</output>
