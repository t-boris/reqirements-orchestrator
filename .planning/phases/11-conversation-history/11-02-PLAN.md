---
phase: 11-conversation-history
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/db/models.py, src/db/listening_store.py, src/slack/handlers/main.py, src/slack/bot.py]
autonomous: true
---

<objective>
Add channel listening state storage and `/maro enable|disable|status` slash commands.

Purpose: Allow users to opt-in to continuous listening per channel. This enables the "already listening" experience when MARO is mentioned.
Output: Database model for listening state, store class, and three slash commands.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-conversation-history/11-RESEARCH.md
@.planning/phases/11-conversation-history/11-CONTEXT.md

Relevant source files:
@src/db/models.py (existing models)
@src/db/channel_context_store.py (existing store pattern)
@src/slack/bot.py (Slack app setup)
@src/slack/handlers/main.py (existing handlers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChannelListeningState model</name>
  <files>src/db/models.py</files>
  <action>
Add new Pydantic model to `src/db/models.py`:

```python
class ChannelListeningState(BaseModel):
    """Tracks whether MARO is actively listening in a channel."""
    team_id: str
    channel_id: str
    enabled: bool = False
    enabled_at: datetime | None = None
    enabled_by: str | None = None  # user_id who enabled
    summary: str | None = None  # Rolling conversation summary
    raw_buffer: list[dict] = Field(default_factory=list)  # Last N messages
    last_summary_at: datetime | None = None
```

This matches the data model from 11-RESEARCH.md.

Also add the model to `__all__` exports if pattern exists.
  </action>
  <verify>python -c "from src.db.models import ChannelListeningState; print('Model OK')"</verify>
  <done>ChannelListeningState model defined and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create ListeningStore</name>
  <files>src/db/listening_store.py</files>
  <action>
Create `src/db/listening_store.py` with async CRUD for listening state:

```python
class ListeningStore:
    """Async store for channel listening state."""

    def __init__(self, pool: asyncpg.Pool):
        self.pool = pool

    async def create_table(self):
        """Create channel_listening_state table if not exists."""
        # Columns: team_id, channel_id, enabled, enabled_at, enabled_by,
        #          summary (text), raw_buffer (jsonb), last_summary_at
        # Primary key: (team_id, channel_id)

    async def get_state(self, team_id: str, channel_id: str) -> ChannelListeningState | None:
        """Get listening state for a channel."""

    async def enable(self, team_id: str, channel_id: str, user_id: str) -> ChannelListeningState:
        """Enable listening for a channel. Returns updated state."""
        # UPSERT with enabled=True, enabled_at=now(), enabled_by=user_id

    async def disable(self, team_id: str, channel_id: str) -> ChannelListeningState | None:
        """Disable listening for a channel. Returns updated state or None if not found."""
        # UPDATE enabled=False, clear enabled_at/enabled_by

    async def is_enabled(self, team_id: str, channel_id: str) -> bool:
        """Quick check if listening is enabled."""

    async def update_summary(self, team_id: str, channel_id: str, summary: str, raw_buffer: list[dict]):
        """Update conversation summary and buffer."""
        # UPDATE summary, raw_buffer, last_summary_at=now()

    async def get_summary(self, team_id: str, channel_id: str) -> tuple[str | None, list[dict]]:
        """Get summary and raw_buffer for a channel."""
```

Follow the pattern from `src/db/channel_context_store.py`:
- Use asyncpg directly
- Handle connection from pool
- JSONB for raw_buffer column
  </action>
  <verify>python -c "from src.db.listening_store import ListeningStore; print('Store OK')"</verify>
  <done>ListeningStore class exists with all methods</done>
</task>

<task type="auto">
  <name>Task 3: Add slash commands</name>
  <files>src/slack/handlers/main.py, src/slack/bot.py</files>
  <action>
1. In `src/slack/bot.py`, add slash command handlers registration after app creation:
   - `/maro enable` - Enable listening in channel
   - `/maro disable` - Disable listening in channel
   - `/maro status` - Show current listening state

2. Create handler functions in `src/slack/handlers/main.py`:

```python
async def handle_maro_enable(ack, command, client, say):
    """Handle /maro enable command."""
    await ack()
    team_id = command["team_id"]
    channel_id = command["channel_id"]
    user_id = command["user_id"]

    # Get or create ListeningStore (use global pool)
    store = ListeningStore(get_db_pool())
    state = await store.enable(team_id, channel_id, user_id)

    # Post confirmation message
    say(
        text="MARO is now listening in this channel to maintain context. "
             "It won't reply unless mentioned or commanded.",
        channel=channel_id
    )

async def handle_maro_disable(ack, command, client, say):
    """Handle /maro disable command."""
    await ack()
    # Similar pattern - call store.disable(), post confirmation

async def handle_maro_status(ack, command, client, say):
    """Handle /maro status command."""
    await ack()
    # Get state, format response showing:
    # - Listening: enabled/disabled
    # - Last summary at: {datetime}
    # - Buffer size: {n} messages
```

3. Register commands in `src/slack/bot.py`:
```python
@app.command("/maro")
def handle_maro_command(ack, command, client, say):
    # Route based on command["text"]: "enable", "disable", "status"
    subcommand = command.get("text", "").strip().lower()
    if subcommand == "enable":
        run_async(handle_maro_enable(ack, command, client, say))
    elif subcommand == "disable":
        run_async(handle_maro_disable(ack, command, client, say))
    elif subcommand == "status":
        run_async(handle_maro_status(ack, command, client, say))
    else:
        ack()
        say(text="Usage: /maro enable | disable | status")
```

Note: Use existing `run_async()` pattern from handlers for async execution.
  </action>
  <verify>python -c "from src.slack.handlers.main import handle_maro_enable, handle_maro_disable, handle_maro_status; print('Commands OK')"</verify>
  <done>Three slash command handlers exist and are registered</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.db.models import ChannelListeningState"` succeeds
- [ ] `python -c "from src.db.listening_store import ListeningStore"` succeeds
- [ ] `python -c "from src.slack.handlers.main import handle_maro_enable"` succeeds
- [ ] No syntax errors in modified files
</verification>

<success_criteria>
- All tasks completed
- ChannelListeningState model defined
- ListeningStore provides async CRUD operations
- /maro enable|disable|status commands registered and handled
- Commands use existing async patterns (run_async)
</success_criteria>

<output>
After completion, create `.planning/phases/11-conversation-history/11-02-SUMMARY.md`
</output>
