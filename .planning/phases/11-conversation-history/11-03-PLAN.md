---
phase: 11-conversation-history
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified: [src/schemas/state.py, src/slack/handlers/main.py, src/graph/runner.py, src/slack/summarizer.py]
autonomous: true
---

<objective>
Integrate conversation history into agent workflow - context injection on @mention and rolling summary updates.

Purpose: Make MARO understand conversation context before responding. When mentioned, MARO should already know what's being discussed.
Output: AgentState extended with conversation_context, handlers inject history before graph runs, rolling summary updates in enabled channels.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-conversation-history/11-RESEARCH.md
@.planning/phases/11-conversation-history/11-CONTEXT.md
@.planning/phases/11-conversation-history/11-01-SUMMARY.md (when available)
@.planning/phases/11-conversation-history/11-02-SUMMARY.md (when available)

Relevant source files:
@src/schemas/state.py (AgentState definition)
@src/slack/handlers/main.py (message handling entry points)
@src/graph/runner.py (GraphRunner state management)
@src/llm/factory.py (LLM access for summarization)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AgentState with conversation_context</name>
  <files>src/schemas/state.py</files>
  <action>
Add new field to `AgentState` TypedDict in `src/schemas/state.py`:

```python
conversation_context: Optional[dict[str, Any]]  # Conversation history context
# Structure: {
#     "messages": [...],        # Raw Slack messages (list of dicts)
#     "summary": "...",         # Compressed narrative (str | None)
#     "last_updated_at": "..."  # ISO datetime string
# }
```

Add appropriate docstring comment explaining the two-layer context pattern:
- `messages`: Last 10-30 raw messages for precision (from raw_buffer or on-demand fetch)
- `summary`: Compressed narrative of older conversation (from rolling summary)

This field is populated by handlers BEFORE the graph runs, giving all nodes access to conversation context.
  </action>
  <verify>python -c "from src.schemas.state import AgentState; print('State OK')"</verify>
  <done>AgentState has conversation_context field</done>
</task>

<task type="auto">
  <name>Task 2: Create summarization service</name>
  <files>src/slack/summarizer.py</files>
  <action>
Create `src/slack/summarizer.py` with rolling summary logic:

```python
SUMMARY_PROMPT = """You are maintaining a rolling summary of a Slack conversation.

Current summary:
{current_summary}

New messages since last update:
{new_messages}

Update the summary to incorporate the new messages. Keep it concise (2-3 paragraphs max).
Focus on: topics discussed, decisions made, open questions, key participants.

Updated summary:"""

async def update_rolling_summary(
    llm_client,  # UnifiedChatClient
    current_summary: str | None,
    new_messages: list[dict],
) -> str:
    """Update summary with new messages using LLM."""
    from src.slack.history import format_messages_for_context

    messages_text = format_messages_for_context(new_messages)
    prompt = SUMMARY_PROMPT.format(
        current_summary=current_summary or "No previous summary.",
        new_messages=messages_text
    )

    response = await llm_client.chat(prompt)
    return response.strip()


async def should_update_summary(
    message_count_since_last: int,
    threshold: int = 10
) -> bool:
    """Determine if summary should be updated (every N messages)."""
    return message_count_since_last >= threshold
```

From research: update every 5-10 messages to balance cost vs freshness. Default to 10.
  </action>
  <verify>python -c "from src.slack.summarizer import update_rolling_summary, should_update_summary; print('Summarizer OK')"</verify>
  <done>Summarization service exists with LLM integration</done>
</task>

<task type="auto">
  <name>Task 3: Inject history in mention handler</name>
  <files>src/slack/handlers/main.py</files>
  <action>
Modify `handle_app_mention()` in `src/slack/handlers/main.py`:

1. Before calling `runner.run_with_message()`, fetch conversation context:

```python
async def _build_conversation_context(client, team_id, channel_id, thread_ts, message_ts):
    """Build conversation context for injection into AgentState."""
    from src.slack.history import fetch_channel_history, fetch_thread_history, ConversationContext
    from src.db.listening_store import ListeningStore

    store = ListeningStore(get_db_pool())

    # Check if listening is enabled
    listening_state = await store.get_state(team_id, channel_id)

    if listening_state and listening_state.enabled:
        # Use stored summary + buffer
        return ConversationContext(
            messages=listening_state.raw_buffer,
            summary=listening_state.summary,
            last_updated_at=listening_state.last_summary_at
        )
    else:
        # On-demand fetch (disabled channel)
        if thread_ts and thread_ts != message_ts:
            # In a thread - fetch thread history
            messages = fetch_thread_history(client, channel_id, thread_ts)
        else:
            # Channel root - fetch recent channel messages
            messages = fetch_channel_history(client, channel_id, before_ts=message_ts, limit=20)

        return ConversationContext(messages=messages, summary=None)
```

2. Update `_process_mention()` to:
   - Call `_build_conversation_context()` before running graph
   - Pass context to runner (add method to GraphRunner or inject into state)

Note: The context should be injected into AgentState BEFORE the graph runs, so nodes can access it.
  </action>
  <verify>grep -q "_build_conversation_context" src/slack/handlers/main.py && echo "Function added"</verify>
  <done>Mention handler fetches and injects conversation context</done>
</task>

<task type="auto">
  <name>Task 4: Update rolling summary on messages</name>
  <files>src/slack/handlers/main.py</files>
  <action>
Modify `handle_message()` in `src/slack/handlers/main.py` to update rolling summary:

1. Check if listening is enabled for the channel
2. If enabled, add message to buffer
3. If buffer exceeds threshold, update summary

```python
async def _update_listening_context(client, team_id, channel_id, message: dict):
    """Update rolling summary for listening-enabled channel."""
    from src.db.listening_store import ListeningStore
    from src.slack.summarizer import update_rolling_summary, should_update_summary
    from src.llm.factory import get_llm_client

    store = ListeningStore(get_db_pool())

    # Check if listening enabled
    if not await store.is_enabled(team_id, channel_id):
        return  # Not listening, skip

    # Get current state
    summary, raw_buffer = await store.get_summary(team_id, channel_id)

    # Add new message to buffer
    raw_buffer = raw_buffer or []
    raw_buffer.append(message)

    # Trim buffer to last 30 messages (keep recent, compress rest)
    if len(raw_buffer) > 30:
        # Take messages to summarize
        to_summarize = raw_buffer[:-20]  # Keep last 20 raw
        raw_buffer = raw_buffer[-20:]

        # Update summary with older messages
        llm = get_llm_client()
        summary = await update_rolling_summary(llm, summary, to_summarize)

    # Store updated state
    await store.update_summary(team_id, channel_id, summary, raw_buffer)
```

Add call to `_update_listening_context()` at the start of `handle_message()` for all messages.

Note: This runs for EVERY message in enabled channels, so keep it lightweight.
  </action>
  <verify>grep -q "_update_listening_context" src/slack/handlers/main.py && echo "Function added"</verify>
  <done>Message handler updates rolling summary for enabled channels</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.schemas.state import AgentState; print(AgentState.__annotations__.get('conversation_context'))"` shows the field
- [ ] `python -c "from src.slack.summarizer import update_rolling_summary"` succeeds
- [ ] `grep "_build_conversation_context" src/slack/handlers/main.py` finds the function
- [ ] `grep "_update_listening_context" src/slack/handlers/main.py` finds the function
- [ ] No syntax errors in modified files
</verification>

<success_criteria>
- All tasks completed
- AgentState has conversation_context field
- Mention handler injects context before graph runs
- Message handler updates rolling summary in enabled channels
- Two-layer context pattern implemented (raw buffer + summary)
</success_criteria>

<output>
After completion, create `.planning/phases/11-conversation-history/11-03-SUMMARY.md`
</output>
