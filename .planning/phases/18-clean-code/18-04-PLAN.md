---
phase: 18-clean-code
plan: 04
type: execute
wave: 3
depends_on: ["18-03"]
files_modified:
  - Multiple src/ files (refactoring)
  - .planning/ISSUES.md (additions)
autonomous: true
---

<objective>
Audit and fix clean code violations: naming, function length, DRY.

Purpose: After files are split (18-01, 18-02) and documented (18-03), audit for remaining clean code violations. This ensures the codebase follows clean code principles beyond just file size.

Output:
- No functions exceeding 50 lines without good reason
- No cryptic variable/function names
- No duplicated code blocks (>10 lines)
- Updated ISSUES.md with any deferred refactoring
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/18-clean-code/18-CONTEXT.md
@.planning/phases/18-clean-code/18-03-SUMMARY.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Audit long functions (>50 lines)</name>
  <files>Multiple src/ files</files>
  <action>
1. Find all functions exceeding 50 lines:
   ```bash
   # Use grep + awk to find function definitions and count lines
   for f in $(find src -name "*.py" -not -path "*/__pycache__/*"); do
     python3 -c "
import ast
import sys

with open('$f', 'r') as file:
    try:
        tree = ast.parse(file.read())
    except:
        sys.exit(0)

for node in ast.walk(tree):
    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
        lines = node.end_lineno - node.lineno + 1
        if lines > 50:
            print(f'$f:{node.lineno}: {node.name}() - {lines} lines')
"
   done
   ```

2. For each long function found, evaluate:
   - Is this a legitimate long function (complex dispatcher, state machine)?
   - Can it be split into smaller helper functions?
   - Does it do ONE thing or multiple things?

3. Refactor functions that can be reasonably split:
   - Extract logical sections into helper functions
   - Use descriptive names for extracted functions
   - Keep related code together

4. For functions that must remain long (e.g., `_dispatch_result`), add:
   - Section comments explaining each block
   - If >100 lines, document in ISSUES.md as "accepted complexity"

**Do NOT split if:**
- Splitting would make code harder to follow
- Function is already well-organized with clear sections
- Function is a single logical operation (like a long switch/match)
  </action>
  <verify>python3 -c "
import ast
import os
for root, dirs, files in os.walk('src'):
    dirs[:] = [d for d in dirs if d != '__pycache__']
    for f in files:
        if f.endswith('.py'):
            path = os.path.join(root, f)
            with open(path) as file:
                try:
                    tree = ast.parse(file.read())
                except:
                    continue
            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    lines = node.end_lineno - node.lineno + 1
                    if lines > 100:
                        print(f'WARNING: {path}:{node.lineno}: {node.name}() - {lines} lines')
print('Audit complete')
"</verify>
  <done>No function exceeds 100 lines; functions 50-100 lines are documented or refactored</done>
</task>

<task type="auto">
  <name>Task 2: Audit naming conventions</name>
  <files>Multiple src/ files</files>
  <action>
1. Scan for problematic naming patterns:
   ```bash
   # Single-letter variables (except i, j, k in loops, e for exception)
   grep -rn "^\s*[a-z]\s*=" src/ --include="*.py" | grep -v "for [ijk] in" | grep -v "except.*as e"

   # Cryptic abbreviations (common bad patterns)
   grep -rn "\b\(msg\|cfg\|ctx\|req\|res\|cb\|fn\|val\|tmp\|buf\)\b" src/ --include="*.py"
   ```

2. Review each finding and evaluate:
   - `msg` → `message` (if it's a Slack/user message, not a log)
   - `cfg` → `config` or `settings`
   - `ctx` → `context` (unless it's a standard library convention)
   - `req` → `request`
   - `res` → `response` or `result`
   - `cb` → `callback`
   - `fn` → `function` or more specific name
   - `val` → `value` or more specific name
   - `tmp` → remove or give meaningful name
   - `buf` → `buffer`

3. **Exceptions (do NOT rename):**
   - Standard library conventions (`ctx` in context managers)
   - Slack Bolt conventions (`ack`, `body`, `client`)
   - Well-established patterns in the codebase
   - Loop variables (`i`, `j`, `k`)
   - Exception handlers (`e`, `ex`, `exc`)

4. Rename variables that are unclear using IDE-safe refactoring:
   - Use `replace_all` parameter in Edit tool
   - Verify imports still work after renaming
  </action>
  <verify>grep -rn "\btmp\b" src/ --include="*.py" | wc -l</verify>
  <done>No cryptic single-letter variables (except loop/exception); common abbreviations reviewed</done>
</task>

<task type="auto">
  <name>Task 3: Find and eliminate code duplication</name>
  <files>Multiple src/ files</files>
  <action>
1. Look for duplicated patterns manually in key areas:
   - Handler boilerplate (ack, async wrapper pattern)
   - Slack block building patterns
   - Error handling patterns
   - Jira API call patterns

2. Common duplication candidates:
   ```bash
   # Find similar error handling blocks
   grep -rn "try:" src/ --include="*.py" -A 5 | head -100

   # Find similar async patterns
   grep -rn "_run_async" src/ --include="*.py"

   # Find similar Slack response patterns
   grep -rn "client.chat_postMessage\|client.chat_update" src/ --include="*.py"
   ```

3. For duplicated code blocks (>10 lines similar):
   - Extract to a helper function in appropriate module
   - Name helper clearly (e.g., `_post_error_to_thread()`)
   - Update all call sites to use helper

4. **Do NOT extract if:**
   - Code is only slightly similar but has important differences
   - Extraction would require many parameters (>3)
   - Code is clearer inline than as a function call
   - It's a well-known pattern (like async wrapper)

5. Document any deferred extractions in ISSUES.md if:
   - Extraction is risky (touches many files)
   - Would require architecture changes
   - Is complex enough to be its own phase
  </action>
  <verify>echo "Manual review - check for obvious copy-paste in handler files"</verify>
  <done>Obvious code duplication eliminated; complex cases documented in ISSUES.md</done>
</task>

<task type="auto">
  <name>Task 4: Final clean code verification</name>
  <files>None (verification only)</files>
  <action>
1. Run all verification checks:
   ```bash
   # File sizes (all under 600 lines)
   find src -name "*.py" -exec wc -l {} \; | awk '$1 > 600 {print "FAIL: " $0; exit 1}'

   # Type checking
   python -m mypy src/ --ignore-missing-imports 2>&1 | head -20

   # Import verification
   python -c "
import src.slack.handlers
import src.slack.blocks
import src.graph.intent
import src.graph.graph
import src.jira.client
print('All imports OK')
"
   ```

2. Run tests:
   ```bash
   python -m pytest tests/ -x --tb=short 2>&1 | tail -30
   ```

3. Generate final stats:
   ```bash
   echo "=== Clean Code Stats ==="
   echo "Total Python files: $(find src -name '*.py' | wc -l)"
   echo "Largest file:"
   find src -name "*.py" -exec wc -l {} \; | sort -rn | head -1
   echo "Files over 300 lines:"
   find src -name "*.py" -exec wc -l {} \; | awk '$1 > 300 {print}'
   ```

4. Update ISSUES.md with any remaining technical debt discovered during audit.
  </action>
  <verify>python -m pytest tests/ -x --tb=short 2>&1 | tail -5</verify>
  <done>All tests pass; all verification checks pass; stats documented</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] No function exceeds 100 lines without documentation
- [ ] No obvious cryptic variable names
- [ ] No obvious code duplication (>15 lines identical)
- [ ] All imports work: `python -c "import src.slack.handlers; import src.slack.blocks"`
- [ ] All tests pass: `python -m pytest tests/ -x`
- [ ] ISSUES.md updated with any deferred refactoring
</verification>

<success_criteria>
- Functions audited: long functions split or documented
- Naming audited: cryptic names improved where safe
- DRY audited: obvious duplication eliminated
- All tests still pass
- Codebase follows clean code principles
</success_criteria>

<output>
After completion, create `.planning/phases/18-clean-code/18-04-SUMMARY.md`
</output>
