---
phase: 18-clean-code
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/slack/blocks.py
  - src/slack/blocks/__init__.py
  - src/slack/blocks/draft.py
  - src/slack/blocks/duplicates.py
  - src/slack/blocks/decisions.py
  - src/slack/blocks/ui.py
  - src/jira/client.py
  - src/jira/operations.py
autonomous: true
---

<objective>
Split blocks.py (850 lines) and jira/client.py (726 lines) into logical modules.

Purpose: Both files exceed the 600-line threshold. blocks.py has distinct block types that can be separated. jira/client.py has new operations from Phase 16 that can be split off.

Output:
- 4 new files under src/slack/blocks/
- 1 new file src/jira/operations.py
- Each file under 500 lines
- Backward compatible imports
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/18-clean-code/18-CONTEXT.md
@src/slack/blocks.py
@src/jira/client.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Analyze blocks.py structure</name>
  <files>src/slack/blocks.py</files>
  <action>
Read blocks.py and identify logical groups of functions:

1. Run: `grep -n "^def " src/slack/blocks.py` to list all functions
2. Group functions by purpose:
   - Draft-related blocks (build_draft_preview, build_approved_preview, etc.)
   - Duplicate-related blocks (build_duplicate_blocks, build_duplicate_modal, etc.)
   - Decision blocks (build_decision_blocks)
   - UI blocks (build_hint_with_buttons, build_persona_indicator, build_help_blocks)

Document the grouping for the next task.
  </action>
  <verify>grep -c "^def " src/slack/blocks.py</verify>
  <done>Function groups identified for splitting</done>
</task>

<task type="auto">
  <name>Task 2: Create blocks/ package with split modules</name>
  <files>src/slack/blocks/__init__.py, src/slack/blocks/draft.py, src/slack/blocks/duplicates.py, src/slack/blocks/decisions.py, src/slack/blocks/ui.py</files>
  <action>
1. Create directory: `src/slack/blocks/`

2. Create `src/slack/blocks/draft.py`:
   - Module docstring: "Slack blocks for ticket draft preview, approval, and rejection."
   - Move draft-related functions:
     - `build_draft_preview()` (main preview builder)
     - `build_approved_preview_blocks()` (if exists, or similar)
     - Any helper functions for draft display
   - Include necessary imports

3. Create `src/slack/blocks/duplicates.py`:
   - Module docstring: "Slack blocks for duplicate ticket handling."
   - Move duplicate-related functions:
     - `build_duplicate_blocks()`
     - `build_duplicate_modal()`
     - `build_dedup_options()`
     - Any helper functions for duplicate display

4. Create `src/slack/blocks/decisions.py`:
   - Module docstring: "Slack blocks for architecture decisions (Phase 14)."
   - Move:
     - `build_decision_blocks()`

5. Create `src/slack/blocks/ui.py`:
   - Module docstring: "Slack blocks for UI elements: hints, buttons, help, personas."
   - Move UI-related functions:
     - `build_hint_with_buttons()`
     - `build_persona_indicator()`
     - `build_help_blocks()`
     - `build_example_blocks()`
     - Any other generic UI builders

6. Create `src/slack/blocks/__init__.py`:
```python
"""Slack block builders.

This package contains block builders split by purpose:
- draft: Ticket draft preview, approval, rejection
- duplicates: Duplicate ticket handling
- decisions: Architecture decision posts
- ui: Generic UI elements (hints, buttons, help)
"""

from src.slack.blocks.draft import (
    build_draft_preview,
    # other draft exports
)
from src.slack.blocks.duplicates import (
    build_duplicate_blocks,
    build_duplicate_modal,
    build_dedup_options,
)
from src.slack.blocks.decisions import build_decision_blocks
from src.slack.blocks.ui import (
    build_hint_with_buttons,
    build_persona_indicator,
    build_help_blocks,
)

__all__ = [
    # Draft
    "build_draft_preview",
    # Duplicates
    "build_duplicate_blocks",
    "build_duplicate_modal",
    "build_dedup_options",
    # Decisions
    "build_decision_blocks",
    # UI
    "build_hint_with_buttons",
    "build_persona_indicator",
    "build_help_blocks",
]
```

7. Delete original `src/slack/blocks.py` after verification.
  </action>
  <verify>python -c "from src.slack.blocks import build_draft_preview, build_decision_blocks; print('OK')"</verify>
  <done>blocks/ package created with all modules, imports working</done>
</task>

<task type="auto">
  <name>Task 3: Split jira/client.py - move operations to separate file</name>
  <files>src/jira/client.py, src/jira/operations.py</files>
  <action>
1. Create `src/jira/operations.py` with:
   - Module docstring: "Extended Jira operations: update, comment, subtask (Phase 16)."
   - Move these methods to standalone async functions:
     - Logic from `update_issue()` method
     - Logic from `add_comment()` method
     - Logic from `create_subtask()` method
   - These take `service: JiraService` as first argument

Actually, better approach: Keep methods in JiraService but extract them as a mixin:

```python
# src/jira/operations.py
"""Extended Jira operations mixin (Phase 16)."""

from typing import Any, Awaitable, Callable, Optional
import logging

logger = logging.getLogger(__name__)


class JiraOperationsMixin:
    """Mixin providing update, comment, and subtask operations.

    Must be mixed with a class that has:
    - self.settings
    - self.base_url
    - self._request()
    - self._mock_issue_counter
    - get_issue()
    """

    async def update_issue(
        self,
        issue_key: str,
        updates: dict[str, Any],
        progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
    ):
        """Update a Jira issue with field changes."""
        # ... implementation

    async def add_comment(
        self,
        issue_key: str,
        comment: str,
        progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
    ) -> dict[str, Any]:
        """Add comment to a Jira issue."""
        # ... implementation

    async def create_subtask(
        self,
        parent_key: str,
        summary: str,
        description: str = "",
        progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
    ):
        """Create a subtask under parent issue."""
        # ... implementation
```

2. Update `src/jira/client.py`:
   - Remove update_issue, add_comment, create_subtask method bodies
   - Import mixin: `from src.jira.operations import JiraOperationsMixin`
   - Make JiraService inherit from mixin: `class JiraService(JiraOperationsMixin):`
   - Keep only core methods in client.py: __init__, _get_session, close, _request, create_issue, search_issues, get_issue

Alternative simpler approach if mixin feels over-engineered:
- Keep JiraService as is
- Just ensure client.py has good section comments separating:
  - Core (init, session, request)
  - CRUD (create_issue, get_issue, search_issues)
  - Operations (update_issue, add_comment, create_subtask)
- If file is under 600 lines after Phase 16 additions, may not need splitting

Check current line count. If under 750, add section comments instead of splitting.
  </action>
  <verify>wc -l src/jira/client.py</verify>
  <done>jira/client.py organized with clear sections OR split with operations.py</done>
</task>

<task type="auto">
  <name>Task 4: Update all imports that reference moved modules</name>
  <files>Multiple files</files>
  <action>
1. Find all files that import from blocks.py:
   ```bash
   grep -r "from src.slack.blocks import\|from src.slack import blocks" src/
   ```

2. Update imports to use package:
   - Most should work unchanged due to __init__.py re-exports
   - Fix any that break

3. Find all files that import from jira/client.py:
   ```bash
   grep -r "from src.jira.client import\|from src.jira import client" src/
   ```

4. Verify no import errors remain.

5. Run a quick syntax check:
   ```bash
   python -m py_compile src/slack/blocks/__init__.py
   python -m py_compile src/jira/client.py
   ```
  </action>
  <verify>python -c "from src.slack.blocks import *; from src.jira.client import JiraService; print('OK')"</verify>
  <done>All imports updated and working</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `wc -l src/slack/blocks/*.py` shows all files under 500 lines
- [ ] `wc -l src/jira/client.py` under 600 lines (or split done)
- [ ] `python -c "from src.slack.blocks import *"` works
- [ ] `python -c "from src.jira.client import JiraService"` works
- [ ] No import errors in any src/ file
</verification>

<success_criteria>
- blocks.py split into 4 logical modules
- jira/client.py under 600 lines (or split appropriately)
- All modules have docstrings
- All imports work correctly
- No functionality changed
</success_criteria>

<output>
After completion, create `.planning/phases/18-clean-code/18-02-SUMMARY.md`
</output>
