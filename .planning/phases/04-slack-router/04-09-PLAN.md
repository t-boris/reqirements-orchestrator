---
phase: 04-slack-router
plan: 09
type: execute
wave: 4
depends_on: ["04-04", "04-06"]
files_modified: [src/slack/contradiction.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Create contradiction detector with structured constraint matching.

Purpose: Implement Rule 3 (Cross-Thread Context) - detect value conflicts on accepted constraints.
Output: Contradiction detector that alerts with approval buttons.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-slack-router/04-CONTEXT.md
@.planning/phases/04-slack-router/04-04-SUMMARY.md
@.planning/phases/04-slack-router/04-06-SUMMARY.md

DoD from CONTEXT for Rule 3: Cross-thread context:
- Bot can answer: "What constraints exist for this epic?"
- Contradiction alerts require:
  - Subject match + conflicting accepted values
  - User confirmation: "Mark as conflict" / "Override previous"

Key principle: Only on accepted constraints. No free-form text contradiction (too noisy).

@src/knowledge/store.py
@src/knowledge/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contradiction detector</name>
  <files>src/slack/contradiction.py</files>
  <action>
Create src/slack/contradiction.py:

```python
"""Contradiction detection for structured constraints.

Rule 3: Cross-Thread Context - Only checks accepted constraints.
Subject match + value differs = conflict.
"""

import logging
from typing import Optional
from slack_sdk.web import WebClient

from src.knowledge.store import KnowledgeStore
from src.knowledge.models import Constraint, ConstraintStatus
from src.slack.session import SessionIdentity

logger = logging.getLogger(__name__)

async def check_for_contradictions(
    epic_key: str,
    subject: str,
    proposed_value: str,
    store: KnowledgeStore,
) -> list[Constraint]:
    """Check if proposed constraint conflicts with existing accepted constraints.

    Returns list of conflicting constraints (same subject, different value).
    """
    conflicts = await store.find_conflicting_constraints(
        epic_id=epic_key,
        subject=subject,
        value=proposed_value,
    )

    if conflicts:
        logger.info(
            f"Contradiction found",
            extra={
                "epic": epic_key,
                "subject": subject,
                "proposed": proposed_value,
                "conflicts": [c.value for c in conflicts],
            }
        )

    return conflicts

def build_contradiction_alert_blocks(
    subject: str,
    proposed_value: str,
    conflicts: list[Constraint],
    source_thread_ts: str,
) -> list[dict]:
    """Build blocks for contradiction alert.

    Shows the conflict and provides resolution actions.
    """
    blocks = []

    # Alert header
    blocks.append({
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": "Potential Contradiction Detected",
            "emoji": True
        }
    })

    # Proposed constraint
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"*New:* `{subject}` = `{proposed_value}`"
        }
    })

    # Existing conflicts
    conflict_text = "*Existing decisions:*\n"
    for c in conflicts:
        thread_link = f"<slack://channel?id={c.thread_ts}|Thread>"
        conflict_text += f"• `{c.subject}` = `{c.value}` ({thread_link})\n"

    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": conflict_text
        }
    })

    # Divider
    blocks.append({"type": "divider"})

    # Actions
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "*How should we resolve this?*"
        }
    })

    # Encode conflict info in action values
    action_data = f"{subject}|{proposed_value}|{source_thread_ts}"

    blocks.append({
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Mark as conflict",
                    "emoji": True
                },
                "value": f"conflict:{action_data}",
                "action_id": "resolve_contradiction_conflict",
                "style": "danger",
            },
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Override previous",
                    "emoji": True
                },
                "value": f"override:{action_data}",
                "action_id": "resolve_contradiction_override",
                "style": "primary",
            },
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Keep both (intentional)",
                    "emoji": True
                },
                "value": f"both:{action_data}",
                "action_id": "resolve_contradiction_both",
            },
        ]
    })

    # Context
    blocks.append({
        "type": "context",
        "elements": [{
            "type": "mrkdwn",
            "text": "Contradictions are detected only between accepted decisions with matching subjects."
        }]
    })

    return blocks

async def maybe_alert_contradiction(
    client: WebClient,
    identity: SessionIdentity,
    epic_key: str,
    subject: str,
    proposed_value: str,
    store: KnowledgeStore,
) -> bool:
    """Check for contradictions and post alert if found.

    Returns True if alert was posted, False otherwise.
    """
    conflicts = await check_for_contradictions(
        epic_key=epic_key,
        subject=subject,
        proposed_value=proposed_value,
        store=store,
    )

    if not conflicts:
        return False

    blocks = build_contradiction_alert_blocks(
        subject=subject,
        proposed_value=proposed_value,
        conflicts=conflicts,
        source_thread_ts=identity.thread_ts,
    )

    client.chat_postMessage(
        channel=identity.channel_id,
        thread_ts=identity.thread_ts,
        text=f"Contradiction detected: {subject}",
        blocks=blocks,
    )

    return True

async def get_constraints_summary(
    epic_key: str,
    store: KnowledgeStore,
) -> str:
    """Get human-readable summary of constraints for an Epic.

    Answers: "What constraints exist for this epic?"
    """
    constraints = await store.get_constraints_for_epic(
        epic_id=epic_key,
        status=ConstraintStatus.ACCEPTED,
    )

    if not constraints:
        return f"No accepted constraints for {epic_key} yet."

    lines = [f"*Accepted constraints for {epic_key}:*\n"]
    for c in constraints:
        lines.append(f"• `{c.subject}` = `{c.value}`")

    return "\n".join(lines)
```
  </action>
  <verify>python -c "from src.slack.contradiction import check_for_contradictions, maybe_alert_contradiction; print('contradiction ok')"</verify>
  <done>Contradiction detector with structured matching</done>
</task>

<task type="auto">
  <name>Task 2: Add contradiction resolution handlers</name>
  <files>src/slack/handlers.py</files>
  <action>
Add contradiction resolution handlers to src/slack/handlers.py:

```python
async def handle_contradiction_conflict(ack, body, client, action):
    """Handle 'Mark as conflict' button - flags both values as conflicting."""
    ack()

    value = action.get("value", "")
    _, data = value.split(":", 1)
    subject, proposed_value, thread_ts = data.split("|")

    channel = body["channel"]["id"]
    message_thread = body["message"].get("thread_ts") or body["message"]["ts"]

    logger.info(
        f"Contradiction marked as conflict",
        extra={"subject": subject, "proposed": proposed_value}
    )

    # TODO: Update constraint status to 'conflicted' in KG
    # TODO: Add to Epic summary as unresolved conflict

    client.chat_postMessage(
        channel=channel,
        thread_ts=message_thread,
        text=f"Marked `{subject}` as having conflicting requirements. This needs team alignment.",
    )

async def handle_contradiction_override(ack, body, client, action):
    """Handle 'Override previous' button - new value supersedes old."""
    ack()

    value = action.get("value", "")
    _, data = value.split(":", 1)
    subject, proposed_value, thread_ts = data.split("|")

    channel = body["channel"]["id"]
    message_thread = body["message"].get("thread_ts") or body["message"]["ts"]

    logger.info(
        f"Contradiction resolved by override",
        extra={"subject": subject, "new_value": proposed_value}
    )

    # TODO: Mark old constraint as 'deprecated'
    # TODO: Mark new constraint as 'accepted'

    client.chat_postMessage(
        channel=channel,
        thread_ts=message_thread,
        text=f"Updated `{subject}` to `{proposed_value}`. Previous value deprecated.",
    )

async def handle_contradiction_both(ack, body, client, action):
    """Handle 'Keep both' button - intentional dual values."""
    ack()

    value = action.get("value", "")
    _, data = value.split(":", 1)
    subject, proposed_value, thread_ts = data.split("|")

    channel = body["channel"]["id"]
    message_thread = body["message"].get("thread_ts") or body["message"]["ts"]

    logger.info(
        f"Contradiction accepted as intentional",
        extra={"subject": subject, "proposed": proposed_value}
    )

    # TODO: Mark both as 'accepted' with note about intentional dual values

    client.chat_postMessage(
        channel=channel,
        thread_ts=message_thread,
        text=f"Noted - keeping both values for `{subject}` as intentional.",
    )
```

Update router.py to register these handlers:
- action_id: "resolve_contradiction_conflict"
- action_id: "resolve_contradiction_override"
- action_id: "resolve_contradiction_both"
  </action>
  <verify>python -c "from src.slack.handlers import handle_contradiction_conflict, handle_contradiction_override; print('resolution handlers ok')"</verify>
  <done>Contradiction resolution action handlers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.slack.contradiction import maybe_alert_contradiction"` succeeds
- [ ] Only checks accepted constraints
- [ ] Subject match + value differs triggers alert
- [ ] Resolution buttons: conflict/override/both
- [ ] get_constraints_summary answers "What constraints exist?"
</verification>

<success_criteria>

- All tasks completed
- Contradiction detection uses structured subject matching
- Alerts only for accepted constraint conflicts
- Resolution actions with approval flow
- DoD: User confirmation required for resolution
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-router/04-09-SUMMARY.md`
</output>
