---
phase: 04-slack-router
plan: 05
type: execute
wave: 1
depends_on: []
files_modified: [src/memory/__init__.py, src/memory/zep_client.py, src/config/settings.py, pyproject.toml, docker-compose.yml]
autonomous: true
---

<objective>
Set up Zep integration for semantic memory storage and search.

Purpose: Enable Epic suggestion via semantic search, store thread summaries for dedup.
Output: Zep client with storage and search APIs (no enforcement yet).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-slack-router/04-CONTEXT.md

Key decisions from CONTEXT:
- Zep for semantic search (Epic suggestions, dedup detection)
- Store first, judge later - no enforcement in this phase
- Zep server via Docker

From PROJECT.md Out of Scope:
- "Zep memory server â€” using PostgreSQL for all persistence"

IMPORTANT: The original project scope excluded Zep. However, the architecture
discussion revised this - Zep is now included for semantic search capabilities
that PostgreSQL alone cannot provide (vector similarity for Epic suggestions).

@src/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Zep dependency and settings</name>
  <files>pyproject.toml, src/config/settings.py</files>
  <action>
Add to pyproject.toml dependencies:
- "zep-python>=2.0"

Add to Settings class in src/config/settings.py:
```python
# Zep (semantic memory)
zep_api_url: str = "http://localhost:8000"
zep_api_key: Optional[str] = None  # Optional for local dev
```
  </action>
  <verify>pip install -e . && python -c "from zep_python import ZepClient; print('zep-python ok')"</verify>
  <done>Zep dependency and settings configured</done>
</task>

<task type="auto">
  <name>Task 2: Add Zep to docker-compose</name>
  <files>docker-compose.yml</files>
  <action>
Add Zep service to docker-compose.yml:

```yaml
  zep:
    image: ghcr.io/getzep/zep:latest
    ports:
      - "8000:8000"
    environment:
      - ZEP_STORE_TYPE=postgres
      - ZEP_STORE_POSTGRES_DSN=postgres://postgres:postgres@db:5432/zep?sslmode=disable
      - ZEP_OPENAI_API_KEY=${OPENAI_API_KEY}  # For embeddings
    depends_on:
      - db
    restart: unless-stopped
```

Note: Zep needs OpenAI API key for embeddings. If using different embedding
provider, adjust ZEP_EMBEDDINGS_* environment variables.
  </action>
  <verify>grep -q "zep:" docker-compose.yml && echo "zep service added"</verify>
  <done>Zep service in docker-compose</done>
</task>

<task type="auto">
  <name>Task 3: Create Zep client wrapper</name>
  <files>src/memory/zep_client.py, src/memory/__init__.py</files>
  <action>
Create src/memory/zep_client.py:

```python
"""Zep client for semantic memory operations.

Provides:
- Epic storage and search (for suggestions)
- Thread summary storage (for dedup detection)

Phase 4: Store and retrieve only, no enforcement.
"""

import logging
from typing import Optional
from zep_python import ZepClient
from zep_python.memory import Memory, Message
from zep_python.user import CreateUserRequest

from src.config import get_settings

logger = logging.getLogger(__name__)

_client: ZepClient | None = None

def get_zep_client() -> ZepClient:
    """Get or create Zep client singleton."""
    global _client
    if _client is None:
        settings = get_settings()
        _client = ZepClient(
            base_url=settings.zep_api_url,
            api_key=settings.zep_api_key,
        )
        logger.info(f"Zep client initialized: {settings.zep_api_url}")
    return _client

# --- Epic Memory Operations ---

async def store_epic(
    epic_key: str,
    summary: str,
    description: str,
    status: str = "active",
) -> None:
    """Store Epic in Zep for semantic search.

    Creates a session for the Epic with its content as memory.
    """
    client = get_zep_client()

    # Use epic_key as session_id
    session_id = f"epic:{epic_key}"

    try:
        # Create session if not exists
        await client.memory.aadd_session(session_id)
    except Exception:
        pass  # Session may already exist

    # Add Epic content as memory
    memory = Memory(
        messages=[
            Message(
                role="system",
                content=f"Epic {epic_key}: {summary}\n\n{description}",
                metadata={
                    "epic_key": epic_key,
                    "status": status,
                    "type": "epic_definition",
                },
            )
        ]
    )

    await client.memory.aadd_memory(session_id, memory)
    logger.info(f"Stored Epic in Zep: {epic_key}")

async def search_epics(
    query: str,
    limit: int = 3,
    status_filter: str = "active",
) -> list[dict]:
    """Search for Epics semantically similar to query.

    Returns list of {epic_key, summary, score} dicts.
    """
    client = get_zep_client()

    try:
        results = await client.memory.asearch_sessions(
            text=query,
            limit=limit,
            metadata_filter={"status": status_filter, "type": "epic_definition"},
        )

        return [
            {
                "epic_key": r.metadata.get("epic_key"),
                "summary": r.message.content[:200] if r.message else "",
                "score": r.score,
            }
            for r in results
            if r.metadata and r.metadata.get("epic_key")
        ]
    except Exception as e:
        logger.warning(f"Epic search failed: {e}")
        return []

# --- Thread Summary Operations ---

async def store_thread_summary(
    session_id: str,
    epic_key: str,
    summary: str,
    key_points: list[str],
) -> None:
    """Store thread summary for dedup detection.

    Args:
        session_id: team:channel:thread_ts
        epic_key: Linked Epic key
        summary: Natural language summary
        key_points: List of key discussion points
    """
    client = get_zep_client()

    try:
        await client.memory.aadd_session(session_id)
    except Exception:
        pass

    memory = Memory(
        messages=[
            Message(
                role="assistant",
                content=f"Thread summary: {summary}\n\nKey points:\n" +
                        "\n".join(f"- {p}" for p in key_points),
                metadata={
                    "epic_key": epic_key,
                    "type": "thread_summary",
                },
            )
        ]
    )

    await client.memory.aadd_memory(session_id, memory)
    logger.info(f"Stored thread summary: {session_id}")

async def search_similar_threads(
    query: str,
    epic_key: Optional[str] = None,
    limit: int = 3,
) -> list[dict]:
    """Search for threads similar to query.

    Used for dedup detection in Phase 4C.

    Args:
        query: Message content to find similar threads
        epic_key: Optionally filter to same Epic
        limit: Max results

    Returns list of {session_id, summary, score} dicts.
    """
    client = get_zep_client()

    try:
        metadata_filter = {"type": "thread_summary"}
        if epic_key:
            metadata_filter["epic_key"] = epic_key

        results = await client.memory.asearch_sessions(
            text=query,
            limit=limit,
            metadata_filter=metadata_filter,
        )

        return [
            {
                "session_id": r.session_id,
                "summary": r.message.content if r.message else "",
                "score": r.score,
            }
            for r in results
        ]
    except Exception as e:
        logger.warning(f"Thread search failed: {e}")
        return []
```

Create src/memory/__init__.py:
```python
"""Memory layer for semantic search and storage."""

from src.memory.zep_client import (
    get_zep_client,
    store_epic,
    search_epics,
    store_thread_summary,
    search_similar_threads,
)

__all__ = [
    "get_zep_client",
    "store_epic",
    "search_epics",
    "store_thread_summary",
    "search_similar_threads",
]
```
  </action>
  <verify>python -c "from src.memory import search_epics, store_epic; print('zep client ok')"</verify>
  <done>Zep client with Epic and thread operations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pip install -e .` succeeds with zep-python
- [ ] `python -c "from src.memory import search_epics"` succeeds
- [ ] Settings has zep_api_url
- [ ] docker-compose.yml has zep service
- [ ] No import errors
</verification>

<success_criteria>

- All tasks completed
- Zep client can be instantiated
- Epic storage and search APIs available
- Thread summary storage available
- Ready for Epic suggestions in 04-04
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-router/04-05-SUMMARY.md`
</output>
