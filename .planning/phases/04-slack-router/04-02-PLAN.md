---
phase: 04-slack-router
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [src/slack/router.py, src/slack/handlers.py, src/slack/app.py]
autonomous: true
---

<objective>
Create message router with @mention detection and slash command handling.

Purpose: Route Slack events to appropriate handlers with fast ack pattern.
Output: Working event handlers for @mentions and /jira commands.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-slack-router/04-CONTEXT.md
@.planning/phases/04-slack-router/04-01-SUMMARY.md

Key decisions from CONTEXT:
- Explicit triggers only: @mention, /jira commands, in-thread replies
- Ignore message subtypes: message_changed, message_deleted, bot messages
- Ack within 3 seconds, enqueue actual work
- Rate limit + backoff for Web API calls

@src/slack/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event handlers</name>
  <files>src/slack/handlers.py</files>
  <action>
Create src/slack/handlers.py with event handlers:

```python
"""Slack event handlers with fast-ack pattern."""

import logging
from slack_bolt import App, Ack, Say, BoltContext
from slack_sdk.web import WebClient

logger = logging.getLogger(__name__)

def handle_app_mention(event: dict, say: Say, client: WebClient, context: BoltContext):
    """Handle @mention events - start or continue conversation.

    Pattern: Ack fast, process async.
    """
    channel = event.get("channel")
    thread_ts = event.get("thread_ts") or event.get("ts")  # Reply in thread
    user = event.get("user")
    text = event.get("text", "")

    logger.info(
        "App mention received",
        extra={
            "channel": channel,
            "thread_ts": thread_ts,
            "user": user,
            "text_preview": text[:100] if text else "",
        }
    )

    # TODO: Route to session handler in 04-04
    # For now, acknowledge receipt
    say(
        text=f"Got it! I'll help you with this.",
        thread_ts=thread_ts,
    )

def handle_message(event: dict, say: Say, client: WebClient, context: BoltContext):
    """Handle message events in threads where bot is already participating.

    Only processes:
    - Messages in threads (has thread_ts)
    - Non-bot messages
    - Non-edited messages
    """
    # Skip non-thread messages (channel root)
    if "thread_ts" not in event:
        return

    # Skip bot messages
    if event.get("bot_id") or event.get("subtype") == "bot_message":
        return

    # Skip message edits/deletes
    subtype = event.get("subtype")
    if subtype in ("message_changed", "message_deleted"):
        return

    channel = event.get("channel")
    thread_ts = event["thread_ts"]
    user = event.get("user")
    text = event.get("text", "")

    logger.info(
        "Thread message received",
        extra={
            "channel": channel,
            "thread_ts": thread_ts,
            "user": user,
        }
    )

    # TODO: Check if bot is in this thread session, route to handler
    # For now, log only

def handle_jira_command(ack: Ack, command: dict, say: Say, client: WebClient):
    """Handle /jira slash command with subcommands.

    Subcommands:
    - /jira create [type] - Start new ticket session
    - /jira search <query> - Search existing tickets
    - /jira status - Show current session status
    """
    ack()  # Ack immediately

    channel = command.get("channel_id")
    user = command.get("user_id")
    text = command.get("text", "").strip()

    # Parse subcommand
    parts = text.split(maxsplit=1)
    subcommand = parts[0].lower() if parts else "help"
    args = parts[1] if len(parts) > 1 else ""

    logger.info(
        "Jira command received",
        extra={
            "channel": channel,
            "user": user,
            "subcommand": subcommand,
            "args": args,
        }
    )

    if subcommand == "create":
        ticket_type = args.capitalize() if args else None
        say(
            text=f"Starting new ticket session{' for ' + ticket_type if ticket_type else ''}...",
            channel=channel,
        )
        # TODO: Route to session creation in 04-04

    elif subcommand == "search":
        if not args:
            say(text="Usage: /jira search <query>", channel=channel)
            return
        say(text=f"Searching for: {args}...", channel=channel)
        # TODO: Implement Jira search in Phase 7

    elif subcommand == "status":
        say(text="No active session in this channel.", channel=channel)
        # TODO: Query session status in 04-04

    else:
        say(
            text="Available commands:\n• `/jira create [type]` - Start new ticket\n• `/jira search <query>` - Search tickets\n• `/jira status` - Session status",
            channel=channel,
        )
```
  </action>
  <verify>python -c "from src.slack.handlers import handle_app_mention, handle_jira_command; print('handlers ok')"</verify>
  <done>Event handlers for @mention, thread messages, and /jira command</done>
</task>

<task type="auto">
  <name>Task 2: Create router that registers handlers</name>
  <files>src/slack/router.py</files>
  <action>
Create src/slack/router.py that registers all handlers with the app:

```python
"""Router that registers all Slack event handlers."""

import logging
from slack_bolt import App

from src.slack.handlers import (
    handle_app_mention,
    handle_message,
    handle_jira_command,
)

logger = logging.getLogger(__name__)

def register_handlers(app: App) -> None:
    """Register all event handlers with the Slack app.

    Call this after get_slack_app() but before start_socket_mode().
    """
    # App mentions - explicit trigger
    app.event("app_mention")(handle_app_mention)

    # Messages - only processes in-thread replies
    app.event("message")(handle_message)

    # Slash command
    app.command("/jira")(handle_jira_command)

    logger.info("Slack handlers registered: app_mention, message, /jira")
```
  </action>
  <verify>python -c "from src.slack.router import register_handlers; print('router ok')"</verify>
  <done>Router registers all handlers with app</done>
</task>

<task type="auto">
  <name>Task 3: Update slack package exports</name>
  <files>src/slack/__init__.py</files>
  <action>
Update src/slack/__init__.py to export:
- get_slack_app (from app)
- start_socket_mode (from app)
- stop_socket_mode (from app)
- register_handlers (from router)

Usage pattern:
```python
from src.slack import get_slack_app, register_handlers, start_socket_mode

app = get_slack_app()
register_handlers(app)
start_socket_mode()  # blocking
```
  </action>
  <verify>python -c "from src.slack import get_slack_app, register_handlers, start_socket_mode; print('exports ok')"</verify>
  <done>Clean exports for slack package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.slack import register_handlers"` succeeds
- [ ] Handlers defined for app_mention, message, /jira command
- [ ] Router registers all handlers
- [ ] No import errors
</verification>

<success_criteria>

- All tasks completed
- @mention handler responds in thread
- /jira command parses subcommands
- Message handler filters correctly (bot, edits, non-thread)
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-router/04-02-SUMMARY.md`
</output>
