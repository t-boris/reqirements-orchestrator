---
phase: 04-slack-router
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-05"]
files_modified: [src/slack/binding.py, src/slack/blocks.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Create Epic binding flow with session card UI.

Purpose: Implement Rule 1 (Context Binding) - every thread bound to an Epic.
Output: Epic suggestion, selection, and session card posting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-slack-router/04-CONTEXT.md
@.planning/phases/04-slack-router/04-02-SUMMARY.md
@.planning/phases/04-slack-router/04-03-SUMMARY.md
@.planning/phases/04-slack-router/04-05-SUMMARY.md

DoD from CONTEXT for Rule 1: Context Binding:
- session(thread_ts) -> epic_id stored
- Pinned "Session Card" message in thread: epic link, status, commands
- LLM only for suggesting epics, not enforcing

@src/slack/handlers.py
@src/slack/session.py
@src/db/session_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Block Kit builders</name>
  <files>src/slack/blocks.py</files>
  <action>
Create src/slack/blocks.py for Slack Block Kit message building:

```python
"""Slack Block Kit builders for rich messages."""

from typing import Optional

def build_session_card(
    epic_key: Optional[str],
    epic_summary: Optional[str],
    session_status: str,
    thread_ts: str,
) -> list[dict]:
    """Build Session Card blocks for thread header.

    Shows: Epic link, session status, available commands.
    """
    blocks = []

    # Header
    blocks.append({
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": "Session Active",
            "emoji": True
        }
    })

    # Epic info section
    if epic_key:
        epic_text = f"*Epic:* <https://jira.example.com/browse/{epic_key}|{epic_key}>"
        if epic_summary:
            epic_text += f" - {epic_summary}"
    else:
        epic_text = "*Epic:* _Not linked yet_"

    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": epic_text
        }
    })

    # Status
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"*Status:* {session_status}"
        }
    })

    # Commands
    blocks.append({
        "type": "context",
        "elements": [{
            "type": "mrkdwn",
            "text": "Commands: `/jira status` | `/jira create` | @mention me"
        }]
    })

    return blocks

def build_epic_selector(
    suggested_epics: list[dict],
    message_preview: str,
) -> list[dict]:
    """Build Epic selection blocks.

    Args:
        suggested_epics: List of {key, summary, score} dicts
        message_preview: First part of user's message for context
    """
    blocks = []

    # Context
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"I see you're discussing: _{message_preview[:100]}..._\n\nWhich Epic does this relate to?"
        }
    })

    # Suggested epics as buttons
    if suggested_epics:
        buttons = []
        for epic in suggested_epics[:3]:  # Max 3 suggestions
            buttons.append({
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": f"{epic['key']}: {epic['summary'][:30]}",
                    "emoji": True
                },
                "value": epic["key"],
                "action_id": f"select_epic_{epic['key']}"
            })

        # Add "New Epic" option
        buttons.append({
            "type": "button",
            "text": {
                "type": "plain_text",
                "text": "New Epic",
                "emoji": True
            },
            "value": "new",
            "action_id": "select_epic_new",
            "style": "primary"
        })

        blocks.append({
            "type": "actions",
            "elements": buttons
        })
    else:
        # No suggestions, just show "New Epic"
        blocks.append({
            "type": "actions",
            "elements": [{
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Create New Epic",
                    "emoji": True
                },
                "value": "new",
                "action_id": "select_epic_new",
                "style": "primary"
            }]
        })

    return blocks
```
  </action>
  <verify>python -c "from src.slack.blocks import build_session_card, build_epic_selector; print('blocks ok')"</verify>
  <done>Block Kit builders for session card and epic selector</done>
</task>

<task type="auto">
  <name>Task 2: Create Epic binding flow</name>
  <files>src/slack/binding.py</files>
  <action>
Create src/slack/binding.py for Epic binding logic:

```python
"""Epic binding flow - connect threads to Epics."""

import logging
from typing import Optional
from slack_sdk.web import WebClient

from src.slack.blocks import build_session_card, build_epic_selector
from src.slack.session import SessionIdentity
from src.db.session_store import SessionStore
from src.memory.zep_client import search_epics  # From 04-05

logger = logging.getLogger(__name__)

async def suggest_epics(text: str, channel_id: str) -> list[dict]:
    """Suggest relevant Epics based on message content.

    Uses Zep semantic search to find related active Epics.
    Returns list of {key, summary, score} dicts.
    """
    try:
        # Search for similar epics using Zep
        results = await search_epics(text, limit=3)
        return [
            {
                "key": r.get("epic_key"),
                "summary": r.get("summary", ""),
                "score": r.get("score", 0.0),
            }
            for r in results
            if r.get("epic_key")
        ]
    except Exception as e:
        logger.warning(f"Epic search failed: {e}")
        return []

async def start_binding_flow(
    client: WebClient,
    identity: SessionIdentity,
    message_text: str,
    store: SessionStore,
) -> None:
    """Start Epic binding flow for new session.

    1. Search for relevant Epics
    2. Post epic selector to thread
    3. Wait for user selection (handled by action handler)
    """
    # Get or create session
    session = await store.get_or_create(
        channel_id=identity.channel_id,
        thread_ts=identity.thread_ts,
    )

    # If already bound, post session card
    if session.epic_id:
        blocks = build_session_card(
            epic_key=session.epic_id,
            epic_summary=None,  # TODO: Fetch from Jira
            session_status="Active",
            thread_ts=identity.thread_ts,
        )
        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text="Session active",
            blocks=blocks,
        )
        return

    # Suggest Epics
    suggested = await suggest_epics(message_text, identity.channel_id)

    # Post epic selector
    blocks = build_epic_selector(
        suggested_epics=suggested,
        message_preview=message_text,
    )

    client.chat_postMessage(
        channel=identity.channel_id,
        thread_ts=identity.thread_ts,
        text="Which Epic does this relate to?",
        blocks=blocks,
    )

async def bind_epic(
    identity: SessionIdentity,
    epic_key: str,
    store: SessionStore,
    client: WebClient,
) -> None:
    """Bind session to selected Epic.

    Called when user clicks Epic selection button.
    """
    # Update session with epic_id
    await store.update_epic(
        channel_id=identity.channel_id,
        thread_ts=identity.thread_ts,
        epic_id=epic_key,
    )

    logger.info(
        f"Session bound to Epic",
        extra={
            "session_id": identity.session_id,
            "epic_key": epic_key,
        }
    )

    # Post session card
    blocks = build_session_card(
        epic_key=epic_key,
        epic_summary=None,  # TODO: Fetch from Jira
        session_status="Active - collecting requirements",
        thread_ts=identity.thread_ts,
    )

    client.chat_postMessage(
        channel=identity.channel_id,
        thread_ts=identity.thread_ts,
        text=f"Session linked to {epic_key}",
        blocks=blocks,
    )
```
  </action>
  <verify>python -c "from src.slack.binding import start_binding_flow, bind_epic; print('binding ok')"</verify>
  <done>Epic binding flow with suggestion and selection</done>
</task>

<task type="auto">
  <name>Task 3: Add action handlers for Epic selection</name>
  <files>src/slack/handlers.py</files>
  <action>
Add Epic selection action handlers to src/slack/handlers.py:

```python
# Add these handlers for Epic selection buttons

async def handle_epic_selection(ack, body, client, action):
    """Handle Epic selection button click."""
    ack()

    epic_key = action.get("value")
    channel = body["channel"]["id"]
    thread_ts = body["message"].get("thread_ts") or body["message"]["ts"]
    team_id = body["team"]["id"]

    identity = SessionIdentity(
        team_id=team_id,
        channel_id=channel,
        thread_ts=thread_ts,
    )

    if epic_key == "new":
        # User wants to create new Epic
        # For now, create a placeholder - full creation in Phase 7
        client.chat_postMessage(
            channel=channel,
            thread_ts=thread_ts,
            text="Creating new Epic... (This will create a Jira Epic in Phase 7)",
        )
        return

    # Bind to selected Epic
    from src.slack.binding import bind_epic
    from src.db.session_store import SessionStore

    store = SessionStore()
    await bind_epic(identity, epic_key, store, client)
```

Also update the router to register action handlers for patterns:
- action_id matching "select_epic_*"
  </action>
  <verify>python -c "from src.slack.handlers import handle_epic_selection; print('action handler ok')"</verify>
  <done>Epic selection action handlers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.slack.blocks import build_session_card"` succeeds
- [ ] `python -c "from src.slack.binding import start_binding_flow"` succeeds
- [ ] Session card shows epic link and status
- [ ] Epic selector shows suggested epics with buttons
- [ ] Action handlers respond to button clicks
</verification>

<success_criteria>

- All tasks completed
- Session card posts to thread with epic info
- Epic selector shows AI-suggested epics
- Button clicks trigger binding flow
- DoD: session(thread_ts) -> epic_id stored
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-router/04-04-SUMMARY.md`
</output>
