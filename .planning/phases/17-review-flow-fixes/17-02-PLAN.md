---
phase: 17-review-flow-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/nodes/extraction.py
  - src/graph/nodes/review.py
  - src/schemas/state.py
  - src/graph/nodes/decision_approval.py
  - tests/test_thread_context_extraction.py
autonomous: true
---

<objective>
Fix thread context extraction for ticket creation and implement review lifecycle to prevent context loss.

Purpose: When user says "Create tickets for THE ARCHITECTURE", extract content from thread instead of asking for criteria. Prevent review_context from being overwritten by subsequent flows until decision is approved and posted.

Output:
- Extraction node detects references ("the architecture", "this review") and uses thread context
- review_context includes state field (ACTIVE, CONTINUATION, APPROVED, POSTED)
- review_node doesn't overwrite ACTIVE review_context with new review
- decision_approval_node marks review_context as POSTED before clearing
- Tests verify reference detection and lifecycle management
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/17-review-flow-fixes/17-CONTEXT.md
@.planning/phases/13-intent-router/13-01-SUMMARY.md
@.planning/phases/14-architecture-decisions/14-01-SUMMARY.md
@src/graph/nodes/extraction.py
@src/graph/nodes/review.py
@src/schemas/state.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add ReviewState enum to schemas</name>
  <files>src/schemas/state.py</files>
  <action>
Add review lifecycle state enum to support review_context state machine:

```python
from enum import Enum

class ReviewState(str, Enum):
    """Lifecycle state for review_context."""
    ACTIVE = "active"              # Review just posted, awaiting user response
    CONTINUATION = "continuation"  # User responded, bot continuing discussion
    APPROVED = "approved"          # User approved, ready to post decision to channel
    POSTED = "posted"             # Decision posted to channel, can clear context

# In AgentState TypedDict, update review_context structure (add documentation):
# review_context: Optional[dict]  # Contains: state (ReviewState), review_summary, topic, thread_ts, channel_id, created_at
```

This enum will be used by review_node, review_continuation_node, and decision_approval_node to manage lifecycle.
  </action>
  <verify>
1. Python imports successfully: `python -c "from src.schemas.state import ReviewState"`
2. All enum values accessible: `python -c "from src.schemas.state import ReviewState; print(ReviewState.ACTIVE)"`
  </verify>
  <done>ReviewState enum added with 4 states (ACTIVE, CONTINUATION, APPROVED, POSTED)</done>
</task>

<task type="auto">
  <name>Task 2: Update review_node to set state=ACTIVE and check for existing review</name>
  <files>src/graph/nodes/review.py</files>
  <action>
Modify review_node to:
1. Check if active review_context already exists (state=ACTIVE or CONTINUATION)
2. If exists, DON'T overwrite - log warning instead
3. When creating new review_context, set state=ReviewState.ACTIVE

```python
async def review_node(state: AgentState) -> dict:
    """LangGraph node for review flow - persona-based analysis."""
    from src.schemas.state import ReviewState

    # ... existing code for persona selection and LLM call

    # BEFORE setting review_context, check if one already exists
    existing_review = state.get("review_context")
    if existing_review and existing_review.get("state") in [ReviewState.ACTIVE, ReviewState.CONTINUATION]:
        logger.warning(
            "Active review already exists, not overwriting",
            extra={
                "existing_topic": existing_review.get("topic"),
                "existing_state": existing_review.get("state"),
            }
        )
        # Don't overwrite - return existing review_context unchanged
        # Still generate new review for user, but don't save as context
        return {
            "decision_result": {
                "action": "review",
                "message": review_message,
                "persona": persona,
            },
            # Keep existing review_context
        }

    # No active review - safe to create new review_context
    import time
    review_context = {
        "state": ReviewState.ACTIVE,  # SET STATE
        "review_summary": review_message,
        "persona": persona,
        "topic": topic,
        "thread_ts": state.get("thread_ts"),
        "channel_id": state.get("channel_id"),
        "created_at": time.time(),
    }

    logger.info(
        "Review node generated analysis",
        extra={"topic": topic, "persona": persona, "state": ReviewState.ACTIVE}
    )

    return {
        "decision_result": {
            "action": "review",
            "message": review_message,
            "persona": persona,
        },
        "review_context": review_context,  # Save with state=ACTIVE
    }
```

This prevents Bug #3 (second review overwriting first review's context).
  </action>
  <verify>
1. Python syntax: `python -m py_compile src/graph/nodes/review.py`
2. Check for ReviewState import: `grep "from src.schemas.state import ReviewState" src/graph/nodes/review.py`
3. Check state is set: `grep "state.*ReviewState.ACTIVE" src/graph/nodes/review.py`
  </verify>
  <done>review_node checks for existing active review before overwriting, sets state=ACTIVE when creating new review_context</done>
</task>

<task type="auto">
  <name>Task 3: Add reference detection to extraction node</name>
  <files>src/graph/nodes/extraction.py</files>
  <action>
Add helper function to detect references like "the architecture", "this review", "that analysis":

```python
def _detect_reference_to_prior_content(message: str) -> bool:
    """Check if user message references prior content in thread.

    Returns True if message contains patterns like:
    - "the architecture" / "this architecture"
    - "the review" / "this review" / "that analysis"
    - "from above" / "mentioned above"
    """
    message_lower = message.lower()

    reference_patterns = [
        r"\bthe\s+(?:architecture|review|analysis|design|proposal|approach)\b",
        r"\bthis\s+(?:architecture|review|analysis|design|proposal|approach)\b",
        r"\bthat\s+(?:architecture|review|analysis|design|proposal|approach)\b",
        r"\b(?:from|mentioned|discussed)\s+above\b",
        r"\bour\s+(?:discussion|conversation|review)\b",
    ]

    import re
    for pattern in reference_patterns:
        if re.search(pattern, message_lower):
            return True
    return False


async def extraction_node(state: AgentState) -> dict:
    """Extract ticket fields from user message."""
    # ... existing code

    # NEW: Check if message references prior content
    user_message = # ... get latest human message
    references_prior_content = _detect_reference_to_prior_content(user_message)

    if references_prior_content:
        # User is referencing something from thread - include conversation context
        conversation_context = state.get("conversation_context", {})
        messages = conversation_context.get("messages", [])

        if messages:
            # Build context string from recent messages (focus on bot's messages)
            context_summary = []
            for msg in messages[-10:]:  # Last 10 messages
                role = msg.get("role", "")
                content = msg.get("content", "")
                if role == "assistant" and len(content) > 100:
                    # This is likely a review or analysis from bot
                    context_summary.append(content)

            thread_context = "\n\n---\n\n".join(context_summary)

            logger.info(
                "User referenced prior content, including thread context",
                extra={"has_context": bool(thread_context)}
            )

            # Update extraction prompt to include thread context
            extraction_prompt = EXTRACTION_PROMPT_WITH_REFERENCE.format(
                message=user_message,
                thread_context=thread_context,
            )
        else:
            # No context available, proceed normally
            extraction_prompt = EXTRACTION_PROMPT.format(message=user_message)
    else:
        # No reference detected, normal extraction
        extraction_prompt = EXTRACTION_PROMPT.format(message=user_message)

    # ... rest of existing extraction logic
```

Also add the new prompt template:
```python
EXTRACTION_PROMPT_WITH_REFERENCE = """
The user is referencing prior discussion in the thread. Here is the recent context:

{thread_context}

---

Now the user says:
{message}

Extract ticket information from the user's request, using the thread context as reference material.
If the user says "create tickets for the architecture" or similar, extract multiple tickets from
the architecture review sections (components, risks, flows, etc.).

[Rest of normal extraction instructions...]
"""
```

This fixes Bug #2 (extraction ignoring thread context).
  </action>
  <verify>
1. Python syntax: `python -m py_compile src/graph/nodes/extraction.py`
2. Test reference detection:
```python
from src.graph.nodes.extraction import _detect_reference_to_prior_content
assert _detect_reference_to_prior_content("Create tickets for the architecture") == True
assert _detect_reference_to_prior_content("Create a new ticket") == False
```
  </verify>
  <done>extraction_node detects references to prior content and includes thread context in extraction prompt</done>
</task>

<task type="auto">
  <name>Task 4: Update decision_approval_node to mark state=POSTED</name>
  <files>src/graph/nodes/decision_approval.py</files>
  <action>
Modify decision_approval_node to mark review_context.state = POSTED before clearing:

```python
async def decision_approval_node(state: AgentState) -> dict:
    """LangGraph node for decision approval flow."""
    from src.schemas.state import ReviewState

    # ... existing code to get approval message

    # Get review context
    review_context = state.get("review_context")

    if review_context:
        # Mark as POSTED before clearing (helps debugging)
        review_context["state"] = ReviewState.POSTED

    logger.info(
        "Decision approval node processing",
        extra={
            "has_review_context": review_context is not None,
            "review_state": review_context.get("state") if review_context else None,
            "approval_preview": approval_message[:50] if approval_message else "",
        }
    )

    # Return with POSTED state, handler will post to channel, then we clear
    return {
        "decision_result": {
            "action": "decision_approval",
            "review_context": review_context,  # Now has state=POSTED
            "approval_message": approval_message,
            "user_id": state.get("user_id", "unknown"),
        },
        "review_context": None,  # Clear after processing (already marked as POSTED)
    }
```

This helps with Bug #4 debugging - we can see in logs if review_context was in correct state.
  </action>
  <verify>
1. Python syntax: `python -m py_compile src/graph/nodes/decision_approval.py`
2. Check ReviewState import: `grep "ReviewState" src/graph/nodes/decision_approval.py`
3. Check state is set to POSTED: `grep 'state.*POSTED' src/graph/nodes/decision_approval.py`
  </verify>
  <done>decision_approval_node marks review_context.state=POSTED before clearing, logs include state for debugging</done>
</task>

<task type="auto">
  <name>Task 5: Add tests for reference detection and lifecycle</name>
  <files>tests/test_thread_context_extraction.py</files>
  <action>
Create new test file for thread context extraction and review lifecycle:

```python
import pytest
from src.graph.nodes.extraction import _detect_reference_to_prior_content
from src.schemas.state import ReviewState

class TestReferenceDetection:
    """Test detection of references to prior content in thread."""

    def test_detects_the_architecture(self):
        """'Create tickets for THE ARCHITECTURE' → detected."""
        assert _detect_reference_to_prior_content("Create Jira tickets that represent the architecture") == True

    def test_detects_this_review(self):
        """'Based on THIS REVIEW' → detected."""
        assert _detect_reference_to_prior_content("Based on this review, create tickets") == True

    def test_detects_from_above(self):
        """'From the discussion above' → detected."""
        assert _detect_reference_to_prior_content("From above, implement the components") == True

    def test_no_reference_in_simple_request(self):
        """'Create a ticket' → NOT detected."""
        assert _detect_reference_to_prior_content("Create a new ticket for user auth") == False

    def test_detects_our_discussion(self):
        """'Based on our discussion' → detected."""
        assert _detect_reference_to_prior_content("Based on our discussion, proceed") == True

class TestReviewLifecycle:
    """Test review_context lifecycle state transitions."""

    def test_review_state_enum_values(self):
        """ReviewState enum has correct values."""
        assert ReviewState.ACTIVE == "active"
        assert ReviewState.CONTINUATION == "continuation"
        assert ReviewState.APPROVED == "approved"
        assert ReviewState.POSTED == "posted"

    def test_active_review_not_overwritten(self):
        """Bug #4: New review doesn't overwrite active review."""
        # This will be tested via integration test with actual graph
        # For now, just verify enum exists
        assert hasattr(ReviewState, 'ACTIVE')

class TestBugReproduction:
    """Reproduce bugs from production thread."""

    def test_bug_2_create_tickets_for_architecture(self):
        """Bug #2: 'Create tickets for the architecture' → detects reference."""
        message = "Create Jira tickets that represent the architecture"
        assert _detect_reference_to_prior_content(message) == True, \
            "Bug #2: Should detect reference to 'the architecture'"

    def test_bug_4_review_context_has_state(self):
        """Bug #4: review_context should have state field."""
        # Verify ReviewState enum exists for lifecycle management
        from src.schemas.state import ReviewState
        assert ReviewState.ACTIVE
        assert ReviewState.POSTED
```

Run tests to ensure they pass.
  </action>
  <verify>
```bash
pytest tests/test_thread_context_extraction.py -v
```

Expected: All tests pass, specifically:
- test_detects_the_architecture PASSED
- test_bug_2_create_tickets_for_architecture PASSED
- test_review_state_enum_values PASSED
  </verify>
  <done>11 new tests added and passing, covering reference detection and review lifecycle state management</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] ReviewState enum exists and imports successfully
- [ ] review_node checks for existing active review before overwriting
- [ ] extraction_node detects references and includes thread context
- [ ] decision_approval_node marks state=POSTED before clearing
- [ ] All test files compile and pass
</verification>

<success_criteria>
- All tasks completed
- review_context includes state field with lifecycle management
- Extraction node detects references like "the architecture"
- Active review_context not overwritten by new reviews
- Tests reproduce and verify Bug #2 and Bug #4 fixes
- No Python syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-review-flow-fixes/17-02-SUMMARY.md`
</output>
