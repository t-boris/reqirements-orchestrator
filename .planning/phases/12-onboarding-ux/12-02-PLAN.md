---
phase: 12-onboarding-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/slack/onboarding.py, src/graph/nodes/extraction.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Implement hesitation detection with LLM classification for contextual hints.

Purpose: When user hesitates or seems uncertain, provide small, precise nudges instead of lectures. Teach by doing, not by lecturing.
Output: Contextual hints appear when user needs guidance, using LLM to detect intent.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-onboarding-ux/12-CONTEXT.md

@src/graph/nodes/extraction.py (current intro/nudge logic)
@src/slack/handlers.py (_dispatch_result handles intro/nudge)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create onboarding module with hesitation detection</name>
  <files>src/slack/onboarding.py</files>
  <action>
Create new module for onboarding logic with LLM-based hesitation detection.

```python
"""Onboarding and contextual hint system.

MARO's onboarding personality: Quiet. Observant. Helpful only when needed.
Teaches by doing, not by lecturing.
"""
import logging
from enum import Enum
from pydantic import BaseModel

logger = logging.getLogger(__name__)


class HintType(str, Enum):
    """Types of contextual hints."""
    GREETING = "greeting"           # User says hi/hello
    VAGUE_IDEA = "vague_idea"       # User mentions something vague
    PERSPECTIVE_NEEDED = "perspective"  # User asks "what do you think"
    CONFUSED = "confused"           # User seems lost
    NONE = "none"                   # No hint needed


class HintResult(BaseModel):
    """Result of hint classification."""
    hint_type: HintType
    hint_message: str = ""
    show_buttons: bool = False
    buttons: list[dict] = []


# Predefined hint responses (from 12-CONTEXT.md)
HINT_RESPONSES = {
    HintType.GREETING: HintResult(
        hint_type=HintType.GREETING,
        hint_message="Hi. I help turn discussions into Jira tickets. Tell me about a feature, bug, or change you want to work on.",
    ),
    HintType.VAGUE_IDEA: HintResult(
        hint_type=HintType.VAGUE_IDEA,
        hint_message="Do you want to create a Jira ticket for that, or just discuss it for now?",
    ),
    HintType.PERSPECTIVE_NEEDED: HintResult(
        hint_type=HintType.PERSPECTIVE_NEEDED,
        hint_message="I can review this as requirements, architecture, or security. Which perspective do you want?",
        show_buttons=True,
        buttons=[
            {"text": "PM", "value": "pm"},
            {"text": "Architect", "value": "architect"},
            {"text": "Security", "value": "security"},
        ],
    ),
    HintType.CONFUSED: HintResult(
        hint_type=HintType.CONFUSED,
        hint_message="Quick tip: you can say things like 'Create a Jira Story for...' or 'Draft requirements for...'",
    ),
}


async def classify_hesitation(message: str, is_first_message: bool = True) -> HintResult:
    """Classify if user message indicates hesitation or need for guidance.

    Uses LLM to understand intent, not just pattern matching.

    Args:
        message: User's message text
        is_first_message: Whether this is first interaction in thread

    Returns:
        HintResult with appropriate hint type and message
    """
    # Quick pattern checks for obvious cases
    message_lower = message.lower().strip()

    # Greeting patterns (simple)
    greeting_words = ["hi", "hello", "hey", "yo", "sup", "morning", "afternoon", "evening"]
    if message_lower in greeting_words or message_lower.rstrip("!") in greeting_words:
        return HINT_RESPONSES[HintType.GREETING]

    # Perspective question pattern
    perspective_patterns = ["what do you think", "your thoughts", "your opinion", "feedback on this"]
    if any(p in message_lower for p in perspective_patterns):
        return HINT_RESPONSES[HintType.PERSPECTIVE_NEEDED]

    # Use LLM for more nuanced classification
    try:
        from src.llm import get_llm

        llm = get_llm()

        prompt = f"""Analyze this message from a user talking to a Jira ticket assistant. Classify the user's intent.

User message: "{message}"

Classify into ONE of these categories:
- VAGUE_IDEA: User mentions something they want but it's unclear if they want a ticket or just discussing (e.g., "we should improve notifications", "the login is slow")
- CONFUSED: User seems lost or uncertain what to do (e.g., "um...", "not sure how this works", random text)
- NONE: User has a clear request or is providing concrete information

Respond with ONLY the category name (VAGUE_IDEA, CONFUSED, or NONE).
If in doubt, respond NONE."""

        result = await llm.chat(prompt)
        classification = result.content.strip().upper()

        if classification == "VAGUE_IDEA":
            return HINT_RESPONSES[HintType.VAGUE_IDEA]
        elif classification == "CONFUSED":
            return HINT_RESPONSES[HintType.CONFUSED]
        else:
            return HintResult(hint_type=HintType.NONE)

    except Exception as e:
        logger.warning(f"Hesitation classification failed: {e}")
        return HintResult(hint_type=HintType.NONE)


def get_intro_message() -> str:
    """Get the intro message for first interaction.

    Used when user's first message results in empty draft.
    """
    return HINT_RESPONSES[HintType.GREETING].hint_message
```
  </action>
  <verify>python -c "from src.slack.onboarding import classify_hesitation, HintType; print('OK')"</verify>
  <done>Onboarding module with hesitation classification created</done>
</task>

<task type="auto">
  <name>Task 2: Update extraction node to use contextual hints</name>
  <files>src/graph/nodes/extraction.py</files>
  <action>
Replace static intro/nudge with dynamic contextual hints.

Find the empty draft handling section (around line 346-374) and update it:

```python
# Handle empty draft - use contextual hints instead of static intro/nudge
is_first_message = state.get("is_first_message", True)
if draft.is_empty():
    # Use onboarding module for contextual hints
    from src.slack.onboarding import classify_hesitation, HintType, get_intro_message

    # Get the user's message for classification
    user_message = ""
    if messages:
        last_human = [m for m in messages if getattr(m, "type", "") == "human"]
        if last_human:
            user_message = last_human[-1].content

    # Classify and get appropriate hint
    hint_result = await classify_hesitation(user_message, is_first_message)

    if hint_result.hint_type == HintType.NONE and is_first_message:
        # No specific hint detected on first message, use intro
        state_update["decision_result"] = {
            "action": "intro",
            "message": get_intro_message(),
        }
    elif hint_result.hint_type == HintType.NONE:
        # No hint needed, use standard nudge
        state_update["decision_result"] = {
            "action": "nudge",
            "message": (
                "I didn't catch any concrete requirements yet.\n"
                "Can you describe the feature, bug, or change you'd like to work on?"
            ),
        }
    else:
        # Return contextual hint
        state_update["decision_result"] = {
            "action": "hint",
            "message": hint_result.hint_message,
            "show_buttons": hint_result.show_buttons,
            "buttons": [b.model_dump() if hasattr(b, 'model_dump') else b for b in hint_result.buttons],
        }

    # Mark first message as done
    state_update["is_first_message"] = False
    logger.info(f"Draft empty, returning contextual hint: {hint_result.hint_type}")
```

Note: This change makes extraction_node async (add `async` to function definition if not already).
  </action>
  <verify>python -c "from src.graph.nodes.extraction import extraction_node; print('OK')"</verify>
  <done>Extraction node uses contextual hints from onboarding module</done>
</task>

<task type="auto">
  <name>Task 3: Update dispatch to handle hint action with buttons</name>
  <files>src/slack/handlers.py</files>
  <action>
Update `_dispatch_result` to handle the new "hint" action with optional buttons.

Find the intro/nudge handling block (around line 290-296) and update:

```python
if action == "intro" or action == "nudge" or action == "hint":
    # Empty draft - send contextual hint message
    message = result.get("message", "Tell me what you'd like to work on.")
    show_buttons = result.get("show_buttons", False)
    buttons = result.get("buttons", [])

    if show_buttons and buttons:
        # Build message with buttons
        from src.slack.blocks import build_hint_with_buttons
        blocks = build_hint_with_buttons(message, buttons)
        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=message,
            blocks=blocks,
        )
    else:
        # Simple text message
        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=message,
        )
```

Also add the button builder to blocks.py:
```python
def build_hint_with_buttons(message: str, buttons: list[dict]) -> list[dict]:
    """Build hint message with action buttons.

    Args:
        message: Hint text
        buttons: List of {text, value} dicts

    Returns:
        Slack blocks with message and buttons
    """
    blocks = [
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": message
            }
        },
        {
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": btn["text"], "emoji": True},
                    "action_id": f"hint_select_{btn['value']}",
                    "value": btn["value"],
                }
                for btn in buttons
            ]
        }
    ]
    return blocks
```
  </action>
  <verify>python -c "from src.slack.handlers import _dispatch_result; from src.slack.blocks import build_hint_with_buttons; print('OK')"</verify>
  <done>Dispatch handles hint action with optional buttons</done>
</task>

<task type="auto">
  <name>Task 4: Add hint button action handlers</name>
  <files>src/slack/router.py, src/slack/handlers.py</files>
  <action>
Add handlers for hint button clicks (persona selection from hint).

In router.py, add action registration:
```python
# Hint button actions (Phase 12 onboarding)
app.action(re.compile(r"^hint_select_.*"))(handle_hint_selection)
```

In handlers.py, add handler:
```python
def handle_hint_selection(ack, body, client: WebClient, action):
    """Handle hint button selection (e.g., persona selection from hint).

    Wraps async handler for sync context.
    """
    ack()
    _run_async(_handle_hint_selection_async(body, client, action))


async def _handle_hint_selection_async(body, client: WebClient, action):
    """Async handler for hint button selection.

    Routes to appropriate action based on button value.
    """
    channel = body["channel"]["id"]
    thread_ts = body["message"].get("thread_ts") or body["message"]["ts"]
    user_id = body["user"]["id"]

    # Get selected value (e.g., "pm", "architect", "security")
    selected = action.get("value", "")

    logger.info(
        "Hint button selected",
        extra={
            "channel": channel,
            "thread_ts": thread_ts,
            "selected": selected,
            "user_id": user_id,
        }
    )

    # Handle persona selection
    if selected in ["pm", "architect", "security"]:
        # Switch persona
        team_id = body["team"]["id"]
        identity = SessionIdentity(
            team_id=team_id,
            channel_id=channel,
            thread_ts=thread_ts,
        )

        try:
            from src.personas.commands import handle_persona_command

            state = {"persona": "pm", "persona_lock": False}
            result = handle_persona_command(selected, state)

            # Update message to confirm selection
            client.chat_postMessage(
                channel=channel,
                thread_ts=thread_ts,
                text=result.message,
            )

            # Update runner state if session exists
            from src.graph.runner import _runners
            if identity.session_id in _runners:
                runner = get_runner(identity)
                current_state = await runner._get_current_state()
                if result.state_update:
                    new_state = {**current_state, **result.state_update}
                    await runner._update_state(new_state)

        except Exception as e:
            logger.warning(f"Failed to handle hint persona selection: {e}")
            client.chat_postMessage(
                channel=channel,
                thread_ts=thread_ts,
                text=f"Switched to {selected} perspective.",
            )
```

Import handle_hint_selection in router.py imports.
  </action>
  <verify>python -c "from src.slack.handlers import handle_hint_selection; print('OK')"</verify>
  <done>Hint button handlers registered and implemented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] "Hi" or "Hello" returns greeting hint (not full intro)
- [ ] "We should improve notifications" returns vague_idea hint with ticket question
- [ ] "What do you think?" returns perspective hint with [PM] [Architect] [Security] buttons
- [ ] Unclear messages return confused hint with tip
- [ ] Clicking persona button switches persona and confirms
- [ ] Clear requests (with actual requirements) proceed normally to extraction
</verification>

<success_criteria>
- All tasks completed
- LLM classification detects hesitation patterns
- Contextual hints are short and precise (one sentence)
- Persona buttons work from hint
</success_criteria>

<output>
After completion, create `.planning/phases/12-onboarding-ux/12-02-SUMMARY.md`
</output>
