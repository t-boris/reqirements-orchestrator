---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src/schemas/ticket.py, src/schemas/state.py, src/schemas/__init__.py]
autonomous: true
---

<objective>
Create core Pydantic schemas: JiraTicketSchema and AgentState.

Purpose: Define the data structures that flow through the entire system - the ticket draft and agent state.
Output: Type-safe, validated schemas ready for use in the agent loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JiraTicketSchema</name>
  <files>src/schemas/ticket.py</files>
  <action>Create JiraTicketSchema using Pydantic v2:

```python
from typing import Literal, Optional
from pydantic import BaseModel, Field

class JiraTicketSchema(BaseModel):
    """Schema for a Jira ticket draft being built through conversation."""

    summary: str = Field(
        default="",
        description="Clear, concise ticket title"
    )
    description: str = Field(
        default="",
        description="Detailed technical description"
    )
    acceptance_criteria: list[str] = Field(
        default_factory=list,
        description="List of conditions for Definition of Done"
    )
    priority: Literal["Highest", "High", "Medium", "Low"] = Field(
        default="Medium",
        description="Jira priority level"
    )
    type: Literal["Epic", "Story", "Task", "Bug"] = Field(
        default="Task",
        description="Jira issue type"
    )

    def is_complete(self) -> bool:
        """Check if ticket has minimum required fields for creation."""
        return bool(
            self.summary
            and self.description
            and len(self.acceptance_criteria) >= 1
        )

    def get_missing_fields(self) -> list[str]:
        """Return list of fields that are missing or incomplete."""
        missing = []
        if not self.summary:
            missing.append("summary")
        if not self.description:
            missing.append("description")
        if not self.acceptance_criteria:
            missing.append("acceptance_criteria (at least one)")
        return missing
```

Key design choices:
- All fields have defaults so partial drafts are valid
- is_complete() method for validation in agent loop
- get_missing_fields() for generating questions
- Use list[str] not List[str] (Python 3.10+ style)</action>
  <verify>python -c "from src.schemas.ticket import JiraTicketSchema; t = JiraTicketSchema(); print(t.is_complete(), t.get_missing_fields())"</verify>
  <done>JiraTicketSchema with validation methods</done>
</task>

<task type="auto">
  <name>Task 2: Create AgentState TypedDict</name>
  <files>src/schemas/state.py</files>
  <action>Create AgentState for LangGraph:

```python
from typing import Literal, Optional, Annotated
from typing_extensions import TypedDict
from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages

from src.schemas.ticket import JiraTicketSchema

class AgentState(TypedDict):
    """State for the Analyst Agent in LangGraph.

    This state flows through the ReAct loop:
    extraction -> validation -> decision -> (loop or complete)
    """

    # Conversation history (LangGraph manages with add_messages reducer)
    messages: Annotated[list[BaseMessage], add_messages]

    # Current ticket draft being built
    draft: Optional[JiraTicketSchema]

    # Questions the agent needs to ask (populated by validation)
    missing_info: list[str]

    # Current status in the ticket lifecycle
    status: Literal["collecting", "ready_to_sync", "synced"]

    # Thread context
    thread_ts: Optional[str]  # Slack thread timestamp (session ID)
    channel_id: Optional[str]  # Slack channel

    # Metadata
    user_id: Optional[str]  # Requesting user
```

Key design choices:
- Use TypedDict (not Pydantic) for LangGraph compatibility
- Annotated[list[BaseMessage], add_messages] for automatic message accumulation
- Include thread_ts and channel_id for Slack context
- Status tracks ticket readiness, not workflow phase</action>
  <verify>python -c "from src.schemas.state import AgentState; print(AgentState.__annotations__.keys())"</verify>
  <done>AgentState TypedDict ready for LangGraph</done>
</task>

<task type="auto">
  <name>Task 3: Update schemas __init__.py with exports</name>
  <files>src/schemas/__init__.py</files>
  <action>Export all schemas from the package:

```python
"""Core schemas for Jira Analyst Bot."""
from src.schemas.ticket import JiraTicketSchema
from src.schemas.state import AgentState

__all__ = ["JiraTicketSchema", "AgentState"]
```

This allows clean imports: `from src.schemas import JiraTicketSchema, AgentState`</action>
  <verify>python -c "from src.schemas import JiraTicketSchema, AgentState; print('OK')"</verify>
  <done>Schemas package exports all core types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] JiraTicketSchema validates correctly
- [ ] JiraTicketSchema.is_complete() returns False for empty, True for filled
- [ ] AgentState is a valid TypedDict
- [ ] `from src.schemas import JiraTicketSchema, AgentState` works
</verification>

<success_criteria>
- All tasks completed
- Schemas are type-safe and validated
- Ready for use in agent loop (Phase 5)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
