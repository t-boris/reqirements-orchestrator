---
phase: 11.2-progress-status-indicators
plan: 04
type: execute
wave: 3
depends_on: ["11.2-02"]
files_modified: [src/slack/progress.py, src/slack/handlers.py, src/jira/client.py]
autonomous: true
---

<objective>
Implement error handling protocol with retry visibility.

Purpose: Show clear error states and retry progress as system operator.
Output: Error messages with retry counts, action buttons after failures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.2-progress-status-indicators/11.2-CONTEXT.md
@.planning/phases/11.2-progress-status-indicators/11.2-02-SUMMARY.md

@src/slack/progress.py
@src/slack/handlers.py
@src/jira/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error state handling to ProgressTracker</name>
  <files>src/slack/progress.py</files>
  <action>
Add error state methods to ProgressTracker.

```python
async def set_error(self, error_type: str, service: str, attempt: int = 1, max_attempts: int = 3):
    """Set error state with retry info.

    Args:
        error_type: Type of error (api_error, timeout, rate_limit)
        service: Service name (Jira, Slack, LLM)
        attempt: Current attempt number
        max_attempts: Maximum retry attempts
    """
    if error_type == "timeout":
        msg = f"⚠️ {service} API timeout. Retrying... ({attempt}/{max_attempts})"
    elif error_type == "rate_limit":
        msg = f"⚠️ {service} API rate-limited. Backing off..."
    else:
        msg = f"⚠️ {service} API error. Retrying... ({attempt}/{max_attempts})"

    await self.update(msg)

async def set_failure(self, service: str, error_msg: str = ""):
    """Set permanent failure state after retries exhausted.

    Shows error with action buttons.
    """
    self._current_status = f"❌ {service} unreachable after retries."
    # Don't delete this message - let user see it
    await self._update_status()
```

Error message formats (from CONTEXT.md):
- "⚠️ Jira API error (timeout). Retrying… (1/3)"
- "⚠️ Slack API rate-limited (429). Backing off 20s…"
- "❌ Jira still unreachable after 3 attempts."
  </action>
  <verify>python -c "from src.slack.progress import ProgressTracker; print('OK')"</verify>
  <done>Error state methods exist in ProgressTracker</done>
</task>

<task type="auto">
  <name>Task 2: Add retry visibility to Jira client</name>
  <files>src/jira/client.py</files>
  <action>
Add optional progress_callback to JiraService methods for retry visibility.

Modify _request method to support callback:
```python
async def _request(
    self,
    method: str,
    path: str,
    json_data: dict | None = None,
    progress_callback: Callable[[str, int, int], Awaitable[None]] | None = None,
) -> dict:
    """Make API request with optional progress callback.

    Args:
        progress_callback: async fn(error_type, attempt, max_attempts)
    """
    max_retries = 3
    for attempt in range(1, max_retries + 1):
        try:
            # existing request logic
            return response_body
        except aiohttp.ClientTimeout:
            if progress_callback:
                await progress_callback("timeout", attempt, max_retries)
            if attempt == max_retries:
                raise
            await asyncio.sleep(5 * attempt)  # exponential backoff
```

Keep callback optional to not break existing code.
Only wire up callback when ProgressTracker is available.
  </action>
  <verify>Test Jira request with forced timeout shows retry status</verify>
  <done>Jira client supports progress callbacks for retry visibility</done>
</task>

<task type="auto">
  <name>Task 3: Wire error handling into approval flow</name>
  <files>src/slack/handlers.py</files>
  <action>
Update _handle_approve_draft_async to show error states.

When Jira creation fails:
1. Show retry progress via ProgressTracker
2. After max retries, show failure with action buttons

```python
async def _handle_approve_draft_async(...):
    tracker = ProgressTracker(client, channel, thread_ts)

    try:
        await tracker.start("Creating ticket...")

        # Create callback for Jira retries
        async def on_retry(error_type: str, attempt: int, max_attempts: int):
            await tracker.set_error(error_type, "Jira", attempt, max_attempts)

        # Pass callback to Jira create
        result = await jira_service.create_issue(
            draft,
            progress_callback=on_retry
        )

        await tracker.complete()

    except Exception as e:
        await tracker.set_failure("Jira", str(e))
        # Post action buttons for user to retry/skip/cancel
        await _post_error_actions(client, channel, thread_ts, str(e))
```

Error action buttons:
- [Retry] - attempts again
- [Skip Jira update] - continues without Jira
- [Cancel] - aborts operation
  </action>
  <verify>Force Jira API error, verify retry messages and failure state appear</verify>
  <done>Error handling integrated into approval flow with action buttons</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Retry attempts show progress (1/3, 2/3, 3/3)
- [ ] Timeout errors show "Retrying..." message
- [ ] After max retries, shows failure with action buttons
- [ ] Error tone is factual, not apologetic
</verification>

<success_criteria>
- All tasks completed
- Errors are visible immediately (no silent failures)
- Users see retry progress and can take action after failures
</success_criteria>

<output>
After completion, create `.planning/phases/11.2-progress-status-indicators/11.2-04-SUMMARY.md`
</output>
