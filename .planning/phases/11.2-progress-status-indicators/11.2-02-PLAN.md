---
phase: 11.2-progress-status-indicators
plan: 02
type: execute
wave: 2
depends_on: ["11.2-01"]
files_modified: [src/slack/progress.py, src/skills/dispatcher.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Add skill-specific status messages and long operation handling.

Purpose: Show what MARO is doing (not internal architecture), handle operations >15s gracefully.
Output: Skill-specific status text, long operation updates with bottleneck info.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.2-progress-status-indicators/11.2-CONTEXT.md
@.planning/phases/11.2-progress-status-indicators/11.2-01-SUMMARY.md

@src/slack/progress.py
@src/skills/dispatcher.py
@src/slack/handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill-specific status messages</name>
  <files>src/slack/progress.py</files>
  <action>
Add predefined status messages for each operation type.

Create STATUS_MESSAGES dict:
```python
STATUS_MESSAGES = {
    "processing": "Processing...",
    "context": "Loading context...",
    "extracting": "Extracting requirements...",
    "validating": "Validating draft...",
    "searching_jira": "Searching Jira...",
    "preparing_preview": "Preparing preview...",
    "creating_ticket": "Creating ticket...",
}
```

Add method to ProgressTracker:
```python
async def set_operation(self, operation: str):
    """Set current operation from predefined list."""
    status = STATUS_MESSAGES.get(operation, operation)
    await self.update(status)
```

Update message format to include elapsed time:
- "⏳ Searching Jira... (5s)"
- Show elapsed in 5-second increments after 10s
  </action>
  <verify>python -c "from src.slack.progress import STATUS_MESSAGES; print(STATUS_MESSAGES)"</verify>
  <done>Skill-specific status messages defined and accessible</done>
</task>

<task type="auto">
  <name>Task 2: Handle long operations (>15s)</name>
  <files>src/slack/progress.py</files>
  <action>
Add long operation handling with bottleneck identification.

When operation exceeds 15 seconds:
1. Update message to show bottleneck: "⏳ Jira is responding slowly (15s)"
2. Update again at 30s with attempt count if retrying

Add to ProgressTracker:
```python
async def _schedule_long_operation_updates(self):
    """Schedule updates for long-running operations."""
    await asyncio.sleep(15)
    if self._status_ts and self._current_status:
        elapsed = int(time.time() - self._start_time)
        bottleneck = self._identify_bottleneck()
        await self._update_with_bottleneck(bottleneck, elapsed)

def _identify_bottleneck(self) -> str:
    """Identify what's slow based on current operation."""
    if "jira" in self._current_status.lower():
        return "Jira API"
    elif "context" in self._current_status.lower():
        return "Context loading"
    else:
        return "Processing"
```

Format: "⏳ {bottleneck} is responding slowly ({elapsed}s). Still waiting..."

Only post ONE update at 15s, ONE at 30s. No continuous heartbeat.
  </action>
  <verify>Manual test with slow Jira API or mocked delay</verify>
  <done>Long operations show bottleneck info at 15s and 30s thresholds</done>
</task>

<task type="auto">
  <name>Task 3: Integrate skill-specific status into dispatcher</name>
  <files>src/skills/dispatcher.py, src/slack/handlers.py</files>
  <action>
Pass ProgressTracker to dispatcher and update status at skill boundaries.

In handlers.py, pass tracker to dispatcher:
```python
dispatcher = SkillDispatcher(identity, client, tracker)
```

In dispatcher.py:
1. Accept optional tracker in __init__
2. Update status before each skill execution:
```python
async def dispatch(self, decision: DecisionResult, draft: TicketDraft | None):
    if self.tracker:
        if decision.action == "preview":
            await self.tracker.set_operation("preparing_preview")
        elif decision.action == "ask":
            await self.tracker.set_operation("processing")
```

Keep it simple - just update at decision points, not during skill execution.
  </action>
  <verify>Test preview flow shows "Preparing preview..." status</verify>
  <done>Dispatcher updates progress tracker with skill-specific status</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Skill-specific status messages appear correctly
- [ ] Long operations (>15s) show bottleneck info
- [ ] Status updates at 15s and 30s, not continuously
- [ ] Dispatcher integration works without breaking existing flow
</verification>

<success_criteria>
- All tasks completed
- Users see what MARO is doing (searching, validating, etc.)
- Long operations don't look like frozen bot
</success_criteria>

<output>
After completion, create `.planning/phases/11.2-progress-status-indicators/11.2-02-SUMMARY.md`
</output>
