---
phase: 09-personas
plan: 04
type: execute
wave: 2
depends_on: ["09-02", "09-03"]
files_modified: [src/personas/commands.py, src/slack/handlers/main.py, src/slack/blocks.py, src/personas/__init__.py]
autonomous: true
---

<objective>
Build persona commands and UX for findings display, locking, and audit logging.

Purpose: User control interface for personas + findings display in preview cards with hybrid approach.
Output: `/persona` commands, @mention triggers, findings UX in preview card, audit logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-personas/09-CONTEXT.md
@.planning/phases/09-personas/09-01-PLAN.md
@.planning/phases/09-personas/09-02-PLAN.md
@.planning/phases/09-personas/09-03-PLAN.md

@src/personas/types.py
@src/personas/config.py
@src/personas/switcher.py
@src/slack/handlers/main.py
@src/slack/blocks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persona command handler</name>
  <files>src/personas/commands.py</files>
  <action>
Create src/personas/commands.py with command parsing and handling:

```python
"""Persona slash command handler.

Commands:
- /persona [name] — Switch to persona (pm, security, architect)
- /persona lock — Lock current persona for thread
- /persona unlock — Allow persona switching again
- /persona auto — Enable auto-detection
- /persona off — Disable persona features
- /persona status — Show current persona, lock state, active validators
- /persona list — Show available personas
"""
import logging
from dataclasses import dataclass
from typing import Any, Optional, Literal

from src.personas.types import PersonaName, PersonaReason
from src.personas.config import PERSONAS, get_persona, PERSONA_VALIDATORS
from src.personas.switcher import PersonaSwitcher, SwitchResult

logger = logging.getLogger(__name__)


@dataclass
class CommandResult:
    """Result of persona command execution."""
    success: bool
    message: str
    state_update: Optional[dict[str, Any]] = None
    blocks: Optional[list[dict]] = None  # Slack blocks for rich response


class PersonaCommandHandler:
    """Handles /persona slash commands."""

    def __init__(self) -> None:
        self._switcher = PersonaSwitcher()

    def parse_command(self, text: str) -> tuple[str, Optional[str]]:
        """Parse command text into action and argument.

        Examples:
            "security" -> ("switch", "security")
            "lock" -> ("lock", None)
            "status" -> ("status", None)
            "" -> ("status", None)  # default
        """
        parts = text.strip().lower().split(maxsplit=1)

        if not parts or not parts[0]:
            return ("status", None)

        action = parts[0]
        arg = parts[1] if len(parts) > 1 else None

        # Check if action is actually a persona name (shortcut)
        if action in [p.value for p in PersonaName]:
            return ("switch", action)

        return (action, arg)

    def execute(
        self,
        action: str,
        arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Execute a persona command.

        Args:
            action: Command action (switch, lock, unlock, status, list, auto, off).
            arg: Optional argument (persona name for switch).
            state: Current AgentState dict.

        Returns:
            CommandResult with response and optional state update.
        """
        handlers = {
            "switch": self._handle_switch,
            "lock": self._handle_lock,
            "unlock": self._handle_unlock,
            "status": self._handle_status,
            "list": self._handle_list,
            "auto": self._handle_auto,
            "off": self._handle_off,
        }

        handler = handlers.get(action, self._handle_unknown)
        return handler(arg, state)

    def _handle_switch(
        self,
        persona_name: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Switch to specified persona."""
        if not persona_name:
            return CommandResult(
                success=False,
                message="Usage: /persona [pm|security|architect]",
            )

        # Validate persona name
        try:
            target = PersonaName(persona_name.lower())
        except ValueError:
            return CommandResult(
                success=False,
                message=f"Unknown persona: {persona_name}. Use: pm, security, architect",
            )

        current = PersonaName(state.get("persona", "pm"))

        # Use switcher for consistent behavior
        switch_result = self._switcher.evaluate_switch(
            message="",  # No message needed for explicit switch
            current_persona=current,
            is_locked=state.get("persona_lock", False),
            force_persona=target,
        )

        if not switch_result.switched:
            return CommandResult(
                success=True,
                message=switch_result.message,
            )

        state_update = self._switcher.apply_switch(state, switch_result)
        persona_config = get_persona(target)

        return CommandResult(
            success=True,
            message=f"{persona_config.emoji} Switched to *{persona_config.display_name}* mode",
            state_update=state_update,
        )

    def _handle_lock(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Lock current persona for thread."""
        if state.get("persona_lock", False):
            return CommandResult(
                success=True,
                message="Persona already locked for this thread",
            )

        state_update = self._switcher.lock(state)
        current = PersonaName(state.get("persona", "pm"))
        persona_config = get_persona(current)

        return CommandResult(
            success=True,
            message=f"Locked {persona_config.emoji} {persona_config.display_name} for this thread",
            state_update=state_update,
        )

    def _handle_unlock(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Unlock persona (allow re-detection)."""
        if not state.get("persona_lock", False):
            return CommandResult(
                success=True,
                message="Persona already unlocked",
            )

        state_update = self._switcher.unlock(state)

        return CommandResult(
            success=True,
            message="Persona unlocked — auto-detection enabled",
            state_update=state_update,
        )

    def _handle_status(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Show current persona status."""
        current = PersonaName(state.get("persona", "pm"))
        persona_config = get_persona(current)
        is_locked = state.get("persona_lock", False)
        reason = state.get("persona_reason", "default")
        confidence = state.get("persona_confidence")

        validators = PERSONA_VALIDATORS.get(current, ())

        status_lines = [
            f"{persona_config.emoji} *Current Persona:* {persona_config.display_name}",
            f"*Lock Status:* {'Locked' if is_locked else 'Unlocked'}",
            f"*Reason:* {reason}" + (f" (confidence: {confidence:.0%})" if confidence else ""),
            f"*Active Validators:* {', '.join(validators) if validators else 'none'}",
        ]

        return CommandResult(
            success=True,
            message="\n".join(status_lines),
        )

    def _handle_list(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """List available personas."""
        lines = ["*Available Personas:*"]

        for name, config in PERSONAS.items():
            validators = ", ".join(PERSONA_VALIDATORS.get(name, ()))
            lines.append(
                f"{config.emoji} *{config.display_name}* (`{name.value}`) — {config.risk_tolerance.value} risk, checks: {validators}"
            )

        return CommandResult(
            success=True,
            message="\n".join(lines),
        )

    def _handle_auto(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Enable auto-detection (same as unlock)."""
        return self._handle_unlock(_arg, state)

    def _handle_off(
        self,
        _arg: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Disable persona features (lock as PM)."""
        state_update = {
            "persona": PersonaName.PM.value,
            "persona_lock": True,
            "persona_reason": PersonaReason.EXPLICIT.value,
        }

        return CommandResult(
            success=True,
            message="Persona features disabled — locked as PM",
            state_update=state_update,
        )

    def _handle_unknown(
        self,
        action: Optional[str],
        state: dict[str, Any],
    ) -> CommandResult:
        """Handle unknown command."""
        return CommandResult(
            success=False,
            message=f"Unknown command: {action}\n\nUsage:\n• /persona [pm|security|architect]\n• /persona lock|unlock|status|list",
        )


# Convenience function
def handle_persona_command(
    text: str,
    state: dict[str, Any],
) -> CommandResult:
    """Handle /persona slash command.

    Args:
        text: Command text (after "/persona ").
        state: Current AgentState dict.

    Returns:
        CommandResult with response.
    """
    handler = PersonaCommandHandler()
    action, arg = handler.parse_command(text)
    return handler.execute(action, arg, state)
```
  </action>
  <verify>python -c "from src.personas.commands import handle_persona_command, PersonaCommandHandler; print('ok')"</verify>
  <done>PersonaCommandHandler with all /persona commands</done>
</task>

<task type="auto">
  <name>Task 2: Create findings display blocks</name>
  <files>src/slack/blocks.py</files>
  <action>
Update src/slack/blocks.py to add findings display for preview cards.

Add new function for findings blocks:

```python
def build_findings_blocks(
    findings: dict[str, Any],
    max_inline: int = 2,
    max_review: int = 5,
) -> list[dict]:
    """Build Slack blocks for validator findings.

    Hybrid approach:
    1. Inline BLOCK findings (max 2) at top
    2. "Review Notes" section for WARN/INFO at bottom
    3. "+N more" if truncated

    Args:
        findings: ValidationFindings.model_dump() dict.
        max_inline: Max BLOCK findings to show inline.
        max_review: Max WARN/INFO findings in review section.

    Returns:
        List of Slack block dicts.
    """
    if not findings or not findings.get("findings"):
        return []

    blocks = []
    all_findings = findings.get("findings", [])

    # Separate by severity
    blocking = [f for f in all_findings if f.get("severity") == "block"]
    warnings = [f for f in all_findings if f.get("severity") == "warn"]
    info = [f for f in all_findings if f.get("severity") == "info"]

    # 1. Inline BLOCK findings (critical, show prominently)
    if blocking:
        inline_blocking = blocking[:max_inline]
        for f in inline_blocking:
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f":warning: *BLOCK:* {f.get('message', '')}",
                },
            })
            if f.get("fix_hint"):
                blocks.append({
                    "type": "context",
                    "elements": [{
                        "type": "mrkdwn",
                        "text": f":bulb: {f.get('fix_hint')}",
                    }],
                })

        remaining_blocking = len(blocking) - max_inline
        if remaining_blocking > 0:
            blocks.append({
                "type": "context",
                "elements": [{
                    "type": "mrkdwn",
                    "text": f"+{remaining_blocking} more blocking issue(s)",
                }],
            })

    # 2. Review Notes section for WARN/INFO
    review_findings = warnings + info
    if review_findings:
        blocks.append({"type": "divider"})
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*Review Notes:*",
            },
        })

        # Group by persona
        by_persona: dict[str, list] = {}
        for f in review_findings[:max_review]:
            persona = f.get("persona", "pm")
            if persona not in by_persona:
                by_persona[persona] = []
            by_persona[persona].append(f)

        for persona, persona_findings in by_persona.items():
            emoji = {"pm": ":memo:", "security": ":shield:", "architect": ":building_construction:"}.get(persona, ":memo:")
            notes = []
            for f in persona_findings:
                severity_emoji = ":large_orange_diamond:" if f.get("severity") == "warn" else ":small_blue_diamond:"
                notes.append(f"{severity_emoji} {f.get('message', '')}")

            blocks.append({
                "type": "context",
                "elements": [{
                    "type": "mrkdwn",
                    "text": f"{emoji} *{persona.upper()}:* " + " | ".join(notes),
                }],
            })

        remaining_review = len(review_findings) - max_review
        if remaining_review > 0:
            blocks.append({
                "type": "context",
                "elements": [{
                    "type": "mrkdwn",
                    "text": f"+{remaining_review} more note(s) — use `/persona status` for details",
                }],
            })

    return blocks


def build_persona_indicator(
    persona: str,
    message_count: int,
    max_indicator_messages: int = 2,
) -> Optional[str]:
    """Build persona indicator prefix for messages.

    Only shows indicator on first 1-2 messages after switch.

    Args:
        persona: Current persona name.
        message_count: Messages since persona change.
        max_indicator_messages: How many messages to show indicator.

    Returns:
        Indicator prefix string or None if past threshold.
    """
    if message_count >= max_indicator_messages:
        return None

    indicators = {
        "pm": ":memo:",
        "security": ":shield:",
        "architect": ":building_construction:",
    }

    emoji = indicators.get(persona, ":memo:")
    names = {
        "pm": "PM",
        "security": "Security",
        "architect": "Architect",
    }

    return f"{emoji} *{names.get(persona, 'PM')}:*"
```
  </action>
  <verify>python -c "from src.slack.blocks import build_findings_blocks, build_persona_indicator; print('ok')"</verify>
  <done>Findings display blocks for preview cards</done>
</task>

<task type="auto">
  <name>Task 3: Integrate persona commands with Slack handlers</name>
  <files>src/slack/handlers/main.py</files>
  <action>
Update src/slack/handlers/main.py to handle /persona command.

Add persona command handler registration. Find where other slash commands are registered and add:

```python
@app.command("/persona")
async def handle_persona_cmd(ack, command, client):
    """Handle /persona slash command."""
    await ack()

    channel_id = command.get("channel_id", "")
    thread_ts = command.get("thread_ts") or command.get("ts", "")
    user_id = command.get("user_id", "")
    text = command.get("text", "").strip()

    try:
        # Get current session state
        from src.slack.session import get_session_store
        from src.personas.commands import handle_persona_command

        async with get_connection() as conn:
            session_store = get_session_store(conn)
            session = await session_store.get_by_thread(channel_id, thread_ts)

            if not session:
                # No session - create minimal state
                state = {
                    "persona": "pm",
                    "persona_lock": False,
                    "persona_reason": "default",
                }
            else:
                state = session.state or {}

            # Execute command
            result = handle_persona_command(text, state)

            # Send response
            client.chat_postMessage(
                channel=channel_id,
                thread_ts=thread_ts,
                text=result.message,
            )

            # Update session if state changed
            if result.state_update and session:
                new_state = {**state, **result.state_update}
                await session_store.update_state(session.id, new_state)

    except Exception as e:
        logger.error(f"Persona command failed: {e}")
        client.chat_postMessage(
            channel=channel_id,
            thread_ts=thread_ts,
            text=f":x: Persona command failed: {e}",
        )
```

Also update the message handler to include persona switching. In the main message handler, after receiving a message:

```python
# Check for persona switch (Phase 9)
from src.personas.switcher import PersonaSwitcher
from src.personas.types import PersonaName

switcher = PersonaSwitcher()
current_persona = PersonaName(state.get("persona", "pm"))
is_locked = state.get("persona_lock", False)

switch_result = switcher.evaluate_switch(
    message=message_text,
    current_persona=current_persona,
    is_locked=is_locked,
)

if switch_result.switched:
    state_update = switcher.apply_switch(state, switch_result)
    # Merge into state
    state = {**state, **state_update}

    # Notify user of switch (only if not explicit)
    if switch_result.reason.value == "detected":
        from src.slack.blocks import build_persona_indicator
        indicator = build_persona_indicator(
            switch_result.persona.value,
            message_count=0,
        )
        if indicator:
            client.chat_postMessage(
                channel=channel_id,
                thread_ts=thread_ts,
                text=f"{indicator} {switch_result.message}",
            )
```
  </action>
  <verify>python -c "from src.slack.handlers.main import handle_persona_cmd; print('ok')" 2>/dev/null || echo "Handler integration needs manual verification"</verify>
  <done>Slack handlers integrated with persona commands</done>
</task>

<task type="auto">
  <name>Task 4: Update preview card with findings</name>
  <files>src/slack/blocks.py</files>
  <action>
Update the preview card builder in src/slack/blocks.py to include findings.

Find `build_preview_card` or similar function and modify to include findings:

```python
def build_preview_card(
    draft: dict[str, Any],
    session_id: str,
    draft_hash: str,
    potential_duplicates: list[dict] = None,
    validator_findings: dict[str, Any] = None,
) -> list[dict]:
    """Build preview card blocks with findings.

    Args:
        draft: TicketDraft dict.
        session_id: Session ID for button values.
        draft_hash: Draft hash for version checking.
        potential_duplicates: Optional duplicate tickets.
        validator_findings: Optional ValidationFindings dict.

    Returns:
        List of Slack block dicts.
    """
    blocks = []

    # Header
    blocks.append({
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": ":ticket: Draft Preview",
        },
    })

    # Check for blocking findings
    has_blocking = validator_findings and validator_findings.get("has_blocking", False)

    # If blocking findings, show them first
    if has_blocking:
        findings_blocks = build_findings_blocks(validator_findings, max_inline=2, max_review=3)
        blocks.extend(findings_blocks)
        blocks.append({"type": "divider"})

    # Draft content
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"*Title:* {draft.get('title', 'Untitled')}",
        },
    })

    if draft.get("problem"):
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Problem:* {draft.get('problem', '')[:500]}",
            },
        })

    if draft.get("acceptance_criteria"):
        ac_text = "\n".join(f"• {ac}" for ac in draft.get("acceptance_criteria", [])[:5])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Acceptance Criteria:*\n{ac_text}",
            },
        })

    # Non-blocking findings at bottom (Review Notes)
    if validator_findings and not has_blocking:
        findings_blocks = build_findings_blocks(validator_findings, max_inline=0, max_review=5)
        if findings_blocks:
            blocks.extend(findings_blocks)

    # Duplicates warning
    if potential_duplicates:
        blocks.append({"type": "divider"})
        dup_text = "\n".join(
            f"• <{d.get('url', '')}|{d.get('key', '')}>: {d.get('summary', '')[:50]}"
            for d in potential_duplicates[:3]
        )
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f":warning: *Potential Duplicates:*\n{dup_text}",
            },
        })

    # Action buttons
    blocks.append({"type": "divider"})

    # Different buttons based on blocking status
    if has_blocking:
        blocks.append({
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Resolve Issues"},
                    "style": "primary",
                    "action_id": "resolve_issues",
                    "value": f"{session_id}:{draft_hash}",
                },
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Edit Draft"},
                    "action_id": "edit_draft",
                    "value": f"{session_id}:{draft_hash}",
                },
            ],
        })
    else:
        blocks.append({
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Approve"},
                    "style": "primary",
                    "action_id": "approve_draft",
                    "value": f"{session_id}:{draft_hash}",
                },
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Edit"},
                    "action_id": "edit_draft",
                    "value": f"{session_id}:{draft_hash}",
                },
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Reject"},
                    "style": "danger",
                    "action_id": "reject_draft",
                    "value": f"{session_id}:{draft_hash}",
                },
            ],
        })

    return blocks
```
  </action>
  <verify>python -c "from src.slack.blocks import build_preview_card; print('ok')" 2>/dev/null || echo "Preview card update needs manual verification"</verify>
  <done>Preview card includes validator findings with hybrid UX</done>
</task>

<task type="auto">
  <name>Task 5: Update personas package exports</name>
  <files>src/personas/__init__.py</files>
  <action>
Update src/personas/__init__.py to export commands module:

```python
"""Persona system - operational modes for the agent.

Personas are Policy + Lens (not "different chatbots"):
- prompt overlay: tone + priorities
- validation policy: extra checks to run
- tool preference: what to ask for, what to preview

Two orthogonal axes:
- persona controls voice and priorities
- validators control safety and correctness
"""
from src.personas.types import (
    PersonaName,
    PersonaReason,
    RiskTolerance,
    ValidatorSeverity,
    ValidatorFinding,
    ValidationFindings,
)
from src.personas.config import (
    PersonaConfig,
    PERSONAS,
    PERSONA_VALIDATORS,
    SILENT_VALIDATORS,
    SENSITIVE_OPS,
    get_persona,
    get_default_persona,
)
from src.personas.detector import (
    TopicDetector,
    DetectionResult,
    SECURITY_KEYWORDS,
    ARCHITECT_KEYWORDS,
)
from src.personas.switcher import (
    PersonaSwitcher,
    SwitchResult,
)
from src.personas.commands import (
    PersonaCommandHandler,
    CommandResult,
    handle_persona_command,
)

__all__ = [
    # Types
    "PersonaName",
    "PersonaReason",
    "RiskTolerance",
    "ValidatorSeverity",
    "ValidatorFinding",
    "ValidationFindings",
    # Config
    "PersonaConfig",
    "PERSONAS",
    "PERSONA_VALIDATORS",
    "SILENT_VALIDATORS",
    "SENSITIVE_OPS",
    "get_persona",
    "get_default_persona",
    # Detector
    "TopicDetector",
    "DetectionResult",
    "SECURITY_KEYWORDS",
    "ARCHITECT_KEYWORDS",
    # Switcher
    "PersonaSwitcher",
    "SwitchResult",
    # Commands
    "PersonaCommandHandler",
    "CommandResult",
    "handle_persona_command",
]
```
  </action>
  <verify>python -c "from src.personas import handle_persona_command, PersonaCommandHandler, CommandResult; print('ok')"</verify>
  <done>All persona exports including commands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.personas.commands import handle_persona_command"` succeeds
- [ ] `python -c "from src.slack.blocks import build_findings_blocks, build_persona_indicator"` succeeds
- [ ] /persona status shows current persona and validators
- [ ] /persona list shows all available personas
- [ ] /persona lock/unlock works
- [ ] Findings display in preview card with hybrid UX
- [ ] Persona indicator shows only first 1-2 messages
- [ ] Blocking findings replace "Approve" with "Resolve Issues"
</verification>

<success_criteria>

- PersonaCommandHandler with all /persona commands (switch, lock, unlock, status, list, auto, off)
- CommandResult with success, message, state_update
- Slack /persona command handler registered
- Message handler integrates persona switching
- build_findings_blocks with hybrid UX (inline BLOCK + Review Notes section)
- build_persona_indicator for first 1-2 messages only
- Preview card shows blocking findings prominently
- "Approve" → "Resolve Issues" when has_blocking
- Audit logging for all persona switches
</success_criteria>

<output>
After completion, create `.planning/phases/09-personas/09-04-SUMMARY.md`
</output>
