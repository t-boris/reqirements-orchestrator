---
phase: 09-personas
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified: [src/personas/validators/__init__.py, src/personas/validators/base.py, src/personas/validators/security.py, src/personas/validators/architect.py, src/personas/validators/pm.py, src/graph/nodes/validation.py, src/graph/nodes/extraction.py]
autonomous: true
---

<objective>
Build pluggable persona-specific validators and integrate with graph nodes.

Purpose: Validators run safety/correctness checks per persona. Silent validators run based on detection without changing persona voice.
Output: `BaseValidator` interface, PM/Security/Architect validators, integration in validation_node.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-personas/09-CONTEXT.md
@.planning/phases/09-personas/09-01-PLAN.md
@.planning/phases/09-personas/09-02-PLAN.md

@src/personas/types.py
@src/personas/config.py
@src/personas/detector.py
@src/graph/nodes/validation.py
@src/graph/nodes/extraction.py
@src/schemas/draft.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base validator interface</name>
  <files>src/personas/validators/base.py</files>
  <action>
Create src/personas/validators/ directory and base.py with validator interface:

```python
"""Base validator interface for persona-specific checks.

Validators are pluggable - each persona has its own set.
Rule-based checks first (cheap heuristics), LLM calls only when needed.

Validators never auto-execute irreversible actions.
They may block workflow progression but never act autonomously.
"""
import logging
from abc import ABC, abstractmethod
from typing import Optional

from src.schemas.draft import TicketDraft
from src.personas.types import (
    PersonaName,
    ValidatorSeverity,
    ValidatorFinding,
    ValidationFindings,
)

logger = logging.getLogger(__name__)


class BaseValidator(ABC):
    """Base class for persona validators.

    Each validator:
    - Has a unique name (e.g., "authz", "scope")
    - Belongs to a persona (PM, Security, Architect)
    - Produces findings with severity (BLOCK, WARN, INFO)
    - Can run silently (no persona switch) based on detection
    """

    def __init__(self, name: str, persona: PersonaName) -> None:
        self.name = name
        self.persona = persona

    @abstractmethod
    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        """Run validation on draft.

        Args:
            draft: Ticket draft to validate.
            context: Optional context (channel_context, etc.).

        Returns:
            List of findings (may be empty if no issues).
        """
        pass

    def _make_finding(
        self,
        id_suffix: str,
        severity: ValidatorSeverity,
        message: str,
        fix_hint: Optional[str] = None,
    ) -> ValidatorFinding:
        """Helper to create a finding with standard ID format."""
        # ID format: PERSONA-VALIDATOR-SUFFIX (e.g., SEC-AUTHZ-001)
        persona_prefix = {
            PersonaName.PM: "PM",
            PersonaName.SECURITY: "SEC",
            PersonaName.ARCHITECT: "ARCH",
        }[self.persona]

        finding_id = f"{persona_prefix}-{self.name.upper()}-{id_suffix}"

        return ValidatorFinding(
            id=finding_id,
            severity=severity,
            message=message[:100],  # Enforce max length
            fix_hint=fix_hint[:100] if fix_hint else None,
            validator=self.name,
            persona=self.persona,
        )


class ValidatorRegistry:
    """Registry of all validators, organized by persona."""

    def __init__(self) -> None:
        self._validators: dict[str, BaseValidator] = {}
        self._by_persona: dict[PersonaName, list[BaseValidator]] = {
            PersonaName.PM: [],
            PersonaName.SECURITY: [],
            PersonaName.ARCHITECT: [],
        }

    def register(self, validator: BaseValidator) -> None:
        """Register a validator."""
        self._validators[validator.name] = validator
        self._by_persona[validator.persona].append(validator)
        logger.debug(f"Registered validator: {validator.name} ({validator.persona.value})")

    def get(self, name: str) -> Optional[BaseValidator]:
        """Get validator by name."""
        return self._validators.get(name)

    def get_for_persona(self, persona: PersonaName) -> list[BaseValidator]:
        """Get all validators for a persona."""
        return self._by_persona[persona]

    def get_by_names(self, names: tuple[str, ...]) -> list[BaseValidator]:
        """Get validators by name list."""
        return [v for name in names if (v := self._validators.get(name))]


# Global registry
_registry: Optional[ValidatorRegistry] = None


def get_validator_registry() -> ValidatorRegistry:
    """Get the global validator registry."""
    global _registry
    if _registry is None:
        _registry = ValidatorRegistry()
        # Registration happens on import of validator modules
    return _registry
```
  </action>
  <verify>python -c "from src.personas.validators.base import BaseValidator, ValidatorRegistry, get_validator_registry; print('ok')"</verify>
  <done>BaseValidator interface and ValidatorRegistry created</done>
</task>

<task type="auto">
  <name>Task 2: Create Security validators</name>
  <files>src/personas/validators/security.py</files>
  <action>
Create src/personas/validators/security.py with security-specific validators:

```python
"""Security persona validators.

Checks: authz, data_retention, secrets, least_privilege
Security warnings are "loud" - high threshold (0.75) for silent activation.
"""
import re
from typing import Optional

from src.schemas.draft import TicketDraft
from src.personas.types import PersonaName, ValidatorSeverity, ValidatorFinding
from src.personas.validators.base import BaseValidator, get_validator_registry


class AuthzValidator(BaseValidator):
    """Checks for authorization model in requirements."""

    def __init__(self) -> None:
        super().__init__("authz", PersonaName.SECURITY)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for auth-related content without explicit authz model
        auth_keywords = ["api", "endpoint", "access", "user", "admin", "role"]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_auth_content = any(kw in content for kw in auth_keywords)
        has_authz_criteria = any(
            "auth" in ac.lower() or "permission" in ac.lower() or "role" in ac.lower()
            for ac in draft.acceptance_criteria
        )

        if has_auth_content and not has_authz_criteria:
            findings.append(self._make_finding(
                "001",
                ValidatorSeverity.WARN,
                "Feature involves user access but no authorization criteria specified",
                fix_hint="Add AC for who can access and with what permissions",
            ))

        return findings


class DataRetentionValidator(BaseValidator):
    """Checks for data retention considerations."""

    def __init__(self) -> None:
        super().__init__("data_retention", PersonaName.SECURITY)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for data storage without retention policy
        storage_keywords = ["store", "save", "persist", "log", "record", "database", "cache"]
        pii_keywords = ["user", "email", "name", "address", "phone", "personal"]

        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_storage = any(kw in content for kw in storage_keywords)
        has_pii = any(kw in content for kw in pii_keywords)

        if has_storage and has_pii:
            has_retention_ac = any(
                "retention" in ac.lower() or "delete" in ac.lower() or "gdpr" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_retention_ac:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.WARN,
                    "Stores user data but no retention policy in acceptance criteria",
                    fix_hint="Add AC for data retention period and deletion",
                ))

        return findings


class SecretsValidator(BaseValidator):
    """Checks for secret/credential handling."""

    def __init__(self) -> None:
        super().__init__("secrets", PersonaName.SECURITY)

    # Patterns that suggest secrets in plain text
    SECRET_PATTERNS = [
        r"api[_-]?key",
        r"password",
        r"secret",
        r"token",
        r"credential",
        r"private[_-]?key",
    ]

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        content = f"{draft.title} {draft.problem} {draft.proposed_solution}"

        # Check if secrets mentioned but no secure handling specified
        has_secrets_mention = any(
            re.search(pattern, content, re.IGNORECASE)
            for pattern in self.SECRET_PATTERNS
        )

        if has_secrets_mention:
            has_secure_handling = any(
                "vault" in ac.lower() or
                "encrypt" in ac.lower() or
                "secure" in ac.lower() or
                "environment" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_secure_handling:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.BLOCK,
                    "Mentions secrets/credentials but no secure handling specified",
                    fix_hint="Add AC for secret storage (vault, env vars, encryption)",
                ))

        return findings


class LeastPrivilegeValidator(BaseValidator):
    """Checks for least privilege principle."""

    def __init__(self) -> None:
        super().__init__("least_privilege", PersonaName.SECURITY)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for broad access patterns
        broad_access_patterns = ["admin", "full access", "all permissions", "superuser", "root"]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        for pattern in broad_access_patterns:
            if pattern in content:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.WARN,
                    f"Mentions '{pattern}' - verify least privilege principle",
                    fix_hint="Specify minimum required permissions",
                ))
                break  # One finding is enough

        return findings


# Register validators on module import
def _register_security_validators() -> None:
    registry = get_validator_registry()
    registry.register(AuthzValidator())
    registry.register(DataRetentionValidator())
    registry.register(SecretsValidator())
    registry.register(LeastPrivilegeValidator())


_register_security_validators()
```
  </action>
  <verify>python -c "from src.personas.validators.security import AuthzValidator, SecretsValidator; from src.personas.validators.base import get_validator_registry; r = get_validator_registry(); print(len(r.get_for_persona(__import__('src.personas.types', fromlist=['PersonaName']).PersonaName.SECURITY)))"</verify>
  <done>Security validators (authz, data_retention, secrets, least_privilege) created</done>
</task>

<task type="auto">
  <name>Task 3: Create Architect validators</name>
  <files>src/personas/validators/architect.py</files>
  <action>
Create src/personas/validators/architect.py with architecture-specific validators:

```python
"""Architect persona validators.

Checks: boundaries, failure_modes, idempotency, scaling
Medium threshold (0.60) for silent activation.
"""
from typing import Optional

from src.schemas.draft import TicketDraft
from src.personas.types import PersonaName, ValidatorSeverity, ValidatorFinding
from src.personas.validators.base import BaseValidator, get_validator_registry


class BoundariesValidator(BaseValidator):
    """Checks for clear system/service boundaries."""

    def __init__(self) -> None:
        super().__init__("boundaries", PersonaName.ARCHITECT)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for integration mentions without boundary definition
        integration_keywords = ["api", "service", "integration", "external", "webhook", "callback"]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_integration = any(kw in content for kw in integration_keywords)

        if has_integration:
            has_boundary_spec = any(
                "interface" in ac.lower() or
                "contract" in ac.lower() or
                "boundary" in ac.lower() or
                "schema" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_boundary_spec:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.INFO,
                    "Involves external integration but no interface/contract specified",
                    fix_hint="Add AC for API contract or interface definition",
                ))

        return findings


class FailureModesValidator(BaseValidator):
    """Checks for failure mode considerations."""

    def __init__(self) -> None:
        super().__init__("failure_modes", PersonaName.ARCHITECT)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for distributed system patterns without failure handling
        distributed_keywords = ["queue", "async", "event", "message", "webhook", "retry"]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_distributed = any(kw in content for kw in distributed_keywords)

        if has_distributed:
            has_failure_handling = any(
                "error" in ac.lower() or
                "fail" in ac.lower() or
                "retry" in ac.lower() or
                "timeout" in ac.lower() or
                "fallback" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_failure_handling:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.WARN,
                    "Distributed operation without failure mode handling specified",
                    fix_hint="Add AC for error handling, retries, timeouts",
                ))

        return findings


class IdempotencyValidator(BaseValidator):
    """Checks for idempotency in write operations."""

    def __init__(self) -> None:
        super().__init__("idempotency", PersonaName.ARCHITECT)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for write operations that should be idempotent
        write_keywords = ["create", "update", "write", "insert", "modify", "change"]
        retry_keywords = ["retry", "webhook", "queue", "event", "async"]

        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_write = any(kw in content for kw in write_keywords)
        has_retry_context = any(kw in content for kw in retry_keywords)

        if has_write and has_retry_context:
            has_idempotency = any(
                "idempotent" in ac.lower() or
                "dedup" in ac.lower() or
                "duplicate" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_idempotency:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.WARN,
                    "Write operation in retry-able context but no idempotency specified",
                    fix_hint="Add AC for idempotency key or deduplication",
                ))

        return findings


class ScalingValidator(BaseValidator):
    """Checks for scaling considerations."""

    def __init__(self) -> None:
        super().__init__("scaling", PersonaName.ARCHITECT)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for bulk/batch operations without scaling consideration
        scale_keywords = ["bulk", "batch", "all", "mass", "import", "export", "sync"]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_scale_op = any(kw in content for kw in scale_keywords)

        if has_scale_op:
            has_scale_consideration = any(
                "limit" in ac.lower() or
                "pagination" in ac.lower() or
                "batch size" in ac.lower() or
                "rate limit" in ac.lower()
                for ac in draft.acceptance_criteria
            )
            if not has_scale_consideration:
                findings.append(self._make_finding(
                    "001",
                    ValidatorSeverity.INFO,
                    "Bulk operation without scale limits specified",
                    fix_hint="Add AC for batch size, pagination, or rate limits",
                ))

        return findings


# Register validators on module import
def _register_architect_validators() -> None:
    registry = get_validator_registry()
    registry.register(BoundariesValidator())
    registry.register(FailureModesValidator())
    registry.register(IdempotencyValidator())
    registry.register(ScalingValidator())


_register_architect_validators()
```
  </action>
  <verify>python -c "from src.personas.validators.architect import BoundariesValidator, IdempotencyValidator; print('ok')"</verify>
  <done>Architect validators (boundaries, failure_modes, idempotency, scaling) created</done>
</task>

<task type="auto">
  <name>Task 4: Create PM validators</name>
  <files>src/personas/validators/pm.py</files>
  <action>
Create src/personas/validators/pm.py with PM-specific validators:

```python
"""PM persona validators.

Checks: scope, acceptance_criteria, risks, dependencies
PM is default persona - these always run.
"""
from typing import Optional

from src.schemas.draft import TicketDraft
from src.personas.types import PersonaName, ValidatorSeverity, ValidatorFinding
from src.personas.validators.base import BaseValidator, get_validator_registry


class ScopeValidator(BaseValidator):
    """Checks for clear scope definition."""

    def __init__(self) -> None:
        super().__init__("scope", PersonaName.PM)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for scope creep indicators
        scope_creep_words = ["also", "additionally", "plus", "and also", "while we're at it"]
        content = f"{draft.problem} {draft.proposed_solution}".lower()

        creep_count = sum(1 for word in scope_creep_words if word in content)
        if creep_count >= 2:
            findings.append(self._make_finding(
                "001",
                ValidatorSeverity.WARN,
                "Multiple scope additions detected - consider splitting into separate tickets",
                fix_hint="Focus on single deliverable per ticket",
            ))

        # Check for vague scope
        vague_words = ["improve", "enhance", "optimize", "better", "more"]
        vague_count = sum(1 for word in vague_words if word in content)
        has_measurable = any(
            char.isdigit() or "%" in ac or "seconds" in ac.lower() or "ms" in ac.lower()
            for ac in draft.acceptance_criteria
        )

        if vague_count >= 2 and not has_measurable:
            findings.append(self._make_finding(
                "002",
                ValidatorSeverity.INFO,
                "Vague improvement language without measurable criteria",
                fix_hint="Add specific metrics or thresholds",
            ))

        return findings


class AcceptanceCriteriaValidator(BaseValidator):
    """Checks acceptance criteria quality."""

    def __init__(self) -> None:
        super().__init__("acceptance_criteria", PersonaName.PM)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for testable criteria
        if not draft.acceptance_criteria:
            findings.append(self._make_finding(
                "001",
                ValidatorSeverity.BLOCK,
                "No acceptance criteria defined",
                fix_hint="Add at least one testable acceptance criterion",
            ))
            return findings

        # Check for untestable criteria
        untestable_words = ["should work", "works well", "good performance", "user-friendly"]
        for i, ac in enumerate(draft.acceptance_criteria):
            ac_lower = ac.lower()
            if any(word in ac_lower for word in untestable_words):
                findings.append(self._make_finding(
                    f"{i+1:03d}",
                    ValidatorSeverity.WARN,
                    f"AC {i+1} may not be testable: '{ac[:40]}...'",
                    fix_hint="Make criterion specific and verifiable",
                ))

        return findings


class RisksValidator(BaseValidator):
    """Checks for risk identification."""

    def __init__(self) -> None:
        super().__init__("risks", PersonaName.PM)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for high-complexity indicators without risk section
        complexity_indicators = [
            "migration", "refactor", "replace", "rewrite",
            "integration", "third-party", "external",
        ]
        content = f"{draft.title} {draft.problem} {draft.proposed_solution}".lower()

        has_complexity = any(ind in content for ind in complexity_indicators)

        if has_complexity and not draft.risks:
            findings.append(self._make_finding(
                "001",
                ValidatorSeverity.INFO,
                "Complex work detected but no risks identified",
                fix_hint="Consider what could go wrong or block progress",
            ))

        return findings


class DependenciesValidator(BaseValidator):
    """Checks for dependency identification."""

    def __init__(self) -> None:
        super().__init__("dependencies", PersonaName.PM)

    async def validate(
        self,
        draft: TicketDraft,
        context: Optional[dict] = None,
    ) -> list[ValidatorFinding]:
        findings = []

        # Check for external dependency indicators
        external_indicators = [
            "api", "service", "team", "approval", "review",
            "design", "spec", "external", "third-party",
        ]
        content = f"{draft.problem} {draft.proposed_solution}".lower()

        has_external = any(ind in content for ind in external_indicators)

        if has_external and not draft.dependencies:
            findings.append(self._make_finding(
                "001",
                ValidatorSeverity.INFO,
                "External dependencies mentioned but not listed",
                fix_hint="List external teams, APIs, or approvals needed",
            ))

        return findings


# Register validators on module import
def _register_pm_validators() -> None:
    registry = get_validator_registry()
    registry.register(ScopeValidator())
    registry.register(AcceptanceCriteriaValidator())
    registry.register(RisksValidator())
    registry.register(DependenciesValidator())


_register_pm_validators()
```
  </action>
  <verify>python -c "from src.personas.validators.pm import ScopeValidator, AcceptanceCriteriaValidator; print('ok')"</verify>
  <done>PM validators (scope, acceptance_criteria, risks, dependencies) created</done>
</task>

<task type="auto">
  <name>Task 5: Create validators package init</name>
  <files>src/personas/validators/__init__.py</files>
  <action>
Create src/personas/validators/__init__.py to export validators:

```python
"""Persona validators package.

Imports all validator modules to trigger registration.
"""
from src.personas.validators.base import (
    BaseValidator,
    ValidatorRegistry,
    get_validator_registry,
)

# Import to trigger registration
from src.personas.validators import security
from src.personas.validators import architect
from src.personas.validators import pm

__all__ = [
    "BaseValidator",
    "ValidatorRegistry",
    "get_validator_registry",
]
```
  </action>
  <verify>python -c "from src.personas.validators import get_validator_registry; r = get_validator_registry(); print(f'Registered: {len(r._validators)} validators')"</verify>
  <done>Validators package with all registrations</done>
</task>

<task type="auto">
  <name>Task 6: Integrate validators with validation_node</name>
  <files>src/graph/nodes/validation.py</files>
  <action>
Update src/graph/nodes/validation.py to run persona-specific validators.

Add after existing ValidationReport class and before validation_node:

```python
async def run_persona_validators(
    draft: TicketDraft,
    persona: str,
    context: Optional[dict] = None,
) -> ValidationFindings:
    """Run validators for the current persona.

    Also runs silent validators based on topic detection.

    Args:
        draft: Ticket draft to validate.
        persona: Current persona name.
        context: Optional context dict.

    Returns:
        ValidationFindings with all findings.
    """
    from src.personas.types import PersonaName, ValidationFindings
    from src.personas.config import PERSONA_VALIDATORS, SILENT_VALIDATORS
    from src.personas.validators import get_validator_registry
    from src.personas.detector import TopicDetector

    findings = ValidationFindings()
    registry = get_validator_registry()

    # Get current persona
    try:
        current_persona = PersonaName(persona)
    except ValueError:
        current_persona = PersonaName.PM

    # Run mandatory validators for current persona
    mandatory_names = PERSONA_VALIDATORS.get(current_persona, ())
    mandatory_validators = registry.get_by_names(mandatory_names)

    for validator in mandatory_validators:
        try:
            validator_findings = await validator.validate(draft, context)
            for f in validator_findings:
                findings.add(f)
        except Exception as e:
            logger.warning(f"Validator {validator.name} failed: {e}")

    # Run silent validators based on topic detection
    # Combine all text for detection
    draft_text = f"{draft.title} {draft.problem} {draft.proposed_solution}"
    detector = TopicDetector()
    detection = detector.detect(draft_text)

    # Security silent checks (if above threshold and not already Security persona)
    if current_persona != PersonaName.SECURITY:
        security_config = SILENT_VALIDATORS.get("security", {})
        if detection.security_score >= security_config.get("threshold", 0.75):
            silent_names = security_config.get("validators", ())
            silent_validators = registry.get_by_names(silent_names)
            for validator in silent_validators:
                if validator not in mandatory_validators:  # Don't run twice
                    try:
                        validator_findings = await validator.validate(draft, context)
                        for f in validator_findings:
                            findings.add(f)
                    except Exception as e:
                        logger.warning(f"Silent validator {validator.name} failed: {e}")

    # Architect silent checks (if above threshold and not already Architect persona)
    if current_persona != PersonaName.ARCHITECT:
        architect_config = SILENT_VALIDATORS.get("architect", {})
        if detection.architect_score >= architect_config.get("threshold", 0.60):
            silent_names = architect_config.get("validators", ())
            silent_validators = registry.get_by_names(silent_names)
            for validator in silent_validators:
                if validator not in mandatory_validators:
                    try:
                        validator_findings = await validator.validate(draft, context)
                        for f in validator_findings:
                            findings.add(f)
                    except Exception as e:
                        logger.warning(f"Silent validator {validator.name} failed: {e}")

    logger.info(
        "Persona validation complete",
        extra={
            "persona": persona,
            "total_findings": len(findings.findings),
            "blocking": findings.has_blocking,
        }
    )

    return findings
```

Update `validation_node` to call persona validators after existing validation:

After the existing validation (LLM or rule-based), add:

```python
    # Run persona-specific validators (Phase 9)
    persona = state.get("persona", "pm")
    channel_context = state.get("channel_context")

    try:
        persona_findings = await run_persona_validators(
            draft=draft,
            persona=persona,
            context=channel_context,
        )

        # Merge blocking findings with is_valid
        if persona_findings.has_blocking:
            report.is_valid = False

    except Exception as e:
        logger.warning(f"Persona validation failed: {e}")
        persona_findings = None
```

Update the return to include validator_findings:

```python
    return {
        "step_count": step_count + 1,
        "phase": next_phase,
        "validation_report": report.model_dump(),
        "validator_findings": persona_findings.model_dump() if persona_findings else None,
    }
```
  </action>
  <verify>python -c "from src.graph.nodes.validation import validation_node, run_persona_validators; print('ok')"</verify>
  <done>Validation node runs persona-specific validators</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.personas.validators import get_validator_registry"` succeeds
- [ ] `python -c "from src.personas.validators.security import AuthzValidator"` succeeds
- [ ] `python -c "from src.personas.validators.architect import IdempotencyValidator"` succeeds
- [ ] `python -c "from src.personas.validators.pm import ScopeValidator"` succeeds
- [ ] Registry has 12 validators (4 per persona)
- [ ] validation_node runs persona validators
- [ ] Silent validators run based on detection threshold
</verification>

<success_criteria>

- BaseValidator abstract class with validate() method and _make_finding() helper
- ValidatorRegistry with register(), get(), get_for_persona(), get_by_names()
- 4 Security validators: authz, data_retention, secrets, least_privilege
- 4 Architect validators: boundaries, failure_modes, idempotency, scaling
- 4 PM validators: scope, acceptance_criteria, risks, dependencies
- Validators auto-register on module import
- validation_node runs mandatory validators for current persona
- Silent validators run when detection score exceeds threshold
- ValidationFindings stored in AgentState.validator_findings
</success_criteria>

<output>
After completion, create `.planning/phases/09-personas/09-03-SUMMARY.md`
</output>
