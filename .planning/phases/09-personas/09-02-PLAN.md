---
phase: 09-personas
plan: 02
type: execute
wave: 1
depends_on: ["09-01"]
files_modified: [src/personas/detector.py, src/personas/switcher.py, src/personas/__init__.py]
autonomous: true
---

<objective>
Build topic detection and persona switching logic with threshold-based detection and deterministic switching.

Purpose: Detect security/architect topics and switch personas only on explicit trigger or high-confidence detection.
Output: `TopicDetector` class with heuristic + optional LLM detection, `PersonaSwitcher` with lock/unlock logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-personas/09-CONTEXT.md
@.planning/phases/09-personas/09-01-PLAN.md

@src/personas/types.py
@src/personas/config.py
@src/schemas/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create topic detector</name>
  <files>src/personas/detector.py</files>
  <action>
Create src/personas/detector.py with threshold-based topic detection:

```python
"""Topic detection for persona-relevant content.

Detection methods in order of preference:
1. Explicit triggers (best): @security, @architect, /persona security
2. Heuristic keywords (good): "threat", "permission", "OAuth" â†’ Security
3. LLM classifier (fine): only with logging and high confidence threshold

Topic drift solution: Multi-persona checks without switching voice.
Stay PM voice but run Security/Architect validators as silent checks.
"""
import logging
import re
from dataclasses import dataclass, field
from typing import Optional

from src.personas.types import PersonaName
from src.personas.config import SILENT_VALIDATORS

logger = logging.getLogger(__name__)


# Heuristic keyword patterns for topic detection
SECURITY_KEYWORDS: tuple[str, ...] = (
    "threat", "permission", "oauth", "pii", "gdpr", "auth", "authz",
    "token", "secret", "credential", "access control", "encryption",
    "vulnerability", "penetration", "security", "compliance", "audit",
    "data retention", "privacy", "sensitive", "classified",
)

ARCHITECT_KEYWORDS: tuple[str, ...] = (
    "scaling", "queue", "idempotent", "idempotency", "architecture",
    "microservice", "api design", "latency", "throughput", "caching",
    "database", "schema", "migration", "failover", "disaster recovery",
    "observability", "monitoring", "tracing", "load balancer",
    "service mesh", "kubernetes", "container", "deployment",
)


@dataclass
class DetectionResult:
    """Result of topic detection."""
    security_score: float = 0.0  # 0.0 - 1.0
    architect_score: float = 0.0  # 0.0 - 1.0
    reasons: list[str] = field(default_factory=list)  # Matched terms/features
    explicit_trigger: Optional[PersonaName] = None  # If explicit @mention or /persona
    method: str = "none"  # "explicit", "heuristic", "llm"

    @property
    def should_switch_to_security(self) -> bool:
        """Check if should switch to Security persona."""
        if self.explicit_trigger == PersonaName.SECURITY:
            return True
        threshold = SILENT_VALIDATORS["security"]["threshold"]
        return self.security_score >= threshold

    @property
    def should_switch_to_architect(self) -> bool:
        """Check if should switch to Architect persona."""
        if self.explicit_trigger == PersonaName.ARCHITECT:
            return True
        threshold = SILENT_VALIDATORS["architect"]["threshold"]
        return self.architect_score >= threshold

    @property
    def suggested_persona(self) -> Optional[PersonaName]:
        """Get suggested persona based on detection."""
        if self.explicit_trigger:
            return self.explicit_trigger
        if self.should_switch_to_security:
            return PersonaName.SECURITY
        if self.should_switch_to_architect:
            return PersonaName.ARCHITECT
        return None


class TopicDetector:
    """Detects security and architecture topics in messages.

    Two-pass detection:
    1. Check for explicit triggers (@security, /persona)
    2. Heuristic keyword matching with scoring

    LLM classification deferred - heuristics sufficient for MVP.
    """

    # Explicit trigger patterns
    EXPLICIT_SECURITY_PATTERN = re.compile(
        r"@security|/persona\s+security",
        re.IGNORECASE
    )
    EXPLICIT_ARCHITECT_PATTERN = re.compile(
        r"@architect|/persona\s+architect",
        re.IGNORECASE
    )
    EXPLICIT_PM_PATTERN = re.compile(
        r"@pm|/persona\s+pm",
        re.IGNORECASE
    )

    def detect(self, message: str) -> DetectionResult:
        """Detect topic relevance in a message.

        Args:
            message: User message to analyze.

        Returns:
            DetectionResult with scores and explicit trigger if found.
        """
        result = DetectionResult()

        # Pass 1: Check explicit triggers (highest priority)
        if self.EXPLICIT_SECURITY_PATTERN.search(message):
            result.explicit_trigger = PersonaName.SECURITY
            result.security_score = 1.0
            result.method = "explicit"
            result.reasons.append("Explicit @security or /persona security trigger")
            logger.info("Explicit Security persona trigger detected")
            return result

        if self.EXPLICIT_ARCHITECT_PATTERN.search(message):
            result.explicit_trigger = PersonaName.ARCHITECT
            result.architect_score = 1.0
            result.method = "explicit"
            result.reasons.append("Explicit @architect or /persona architect trigger")
            logger.info("Explicit Architect persona trigger detected")
            return result

        if self.EXPLICIT_PM_PATTERN.search(message):
            result.explicit_trigger = PersonaName.PM
            result.method = "explicit"
            result.reasons.append("Explicit @pm or /persona pm trigger")
            logger.info("Explicit PM persona trigger detected")
            return result

        # Pass 2: Heuristic keyword matching
        message_lower = message.lower()

        # Security keywords
        security_matches = []
        for keyword in SECURITY_KEYWORDS:
            if keyword in message_lower:
                security_matches.append(keyword)

        # Architect keywords
        architect_matches = []
        for keyword in ARCHITECT_KEYWORDS:
            if keyword in message_lower:
                architect_matches.append(keyword)

        # Calculate scores (diminishing returns for multiple matches)
        if security_matches:
            # Score: 0.3 for first match, +0.15 for each additional (max 0.9)
            result.security_score = min(0.3 + 0.15 * (len(security_matches) - 1), 0.9)
            result.reasons.extend([f"Security keyword: {kw}" for kw in security_matches[:3]])
            result.method = "heuristic"

        if architect_matches:
            result.architect_score = min(0.3 + 0.15 * (len(architect_matches) - 1), 0.9)
            result.reasons.extend([f"Architect keyword: {kw}" for kw in architect_matches[:3]])
            result.method = "heuristic"

        if result.method == "heuristic":
            logger.debug(
                "Heuristic detection",
                extra={
                    "security_score": result.security_score,
                    "architect_score": result.architect_score,
                    "security_matches": len(security_matches),
                    "architect_matches": len(architect_matches),
                }
            )

        return result

    def detect_sensitive_op(self, operation: str) -> bool:
        """Check if operation is sensitive (always requires Security check).

        Args:
            operation: Operation name (e.g., "jira_create").

        Returns:
            True if operation is in SENSITIVE_OPS list.
        """
        from src.personas.config import SENSITIVE_OPS
        return operation in SENSITIVE_OPS
```
  </action>
  <verify>python -c "from src.personas.detector import TopicDetector, DetectionResult; d = TopicDetector(); r = d.detect('@security review this'); print(r.explicit_trigger)"</verify>
  <done>TopicDetector with explicit trigger and heuristic keyword detection</done>
</task>

<task type="auto">
  <name>Task 2: Create persona switcher</name>
  <files>src/personas/switcher.py</files>
  <action>
Create src/personas/switcher.py with deterministic persona switching:

```python
"""Persona switching logic with lock/unlock and audit trail.

Rules:
- PM is always default
- Switch only on explicit trigger or high-confidence detection
- Auto-lock once activated (prevents oscillation)
- Every switch is auditable
"""
import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Optional

from src.personas.types import PersonaName, PersonaReason
from src.personas.config import get_persona, get_default_persona
from src.personas.detector import TopicDetector, DetectionResult

logger = logging.getLogger(__name__)


@dataclass
class SwitchResult:
    """Result of persona switch attempt."""
    switched: bool = False
    persona: PersonaName = PersonaName.PM
    reason: PersonaReason = PersonaReason.DEFAULT
    confidence: Optional[float] = None
    locked: bool = False
    message: str = ""  # Human-readable explanation


class PersonaSwitcher:
    """Manages persona switching with lock/unlock logic.

    Key behaviors:
    - PM is always default
    - Explicit triggers always work (even when locked, but logs warning)
    - Detection-based switches only work when unlocked
    - Auto-lock on any switch (prevents oscillation)
    - Users can /persona unlock to allow re-detection
    """

    def __init__(self) -> None:
        self._detector = TopicDetector()

    def get_initial_state(self) -> dict[str, Any]:
        """Get initial persona state for new thread."""
        return {
            "persona": PersonaName.PM.value,
            "persona_lock": False,
            "persona_reason": PersonaReason.DEFAULT.value,
            "persona_confidence": None,
            "persona_changed_at": datetime.now(timezone.utc).isoformat(),
            "persona_message_count": 0,
        }

    def evaluate_switch(
        self,
        message: str,
        current_persona: PersonaName,
        is_locked: bool,
        force_persona: Optional[PersonaName] = None,
    ) -> SwitchResult:
        """Evaluate whether to switch persona based on message.

        Args:
            message: User message to analyze.
            current_persona: Currently active persona.
            is_locked: Whether persona is locked for thread.
            force_persona: Force switch to specific persona (for /persona command).

        Returns:
            SwitchResult with switch decision.
        """
        result = SwitchResult(persona=current_persona, locked=is_locked)

        # Handle forced persona switch (from /persona command)
        if force_persona:
            if force_persona == current_persona:
                result.message = f"Already in {current_persona.value} mode"
                return result

            result.switched = True
            result.persona = force_persona
            result.reason = PersonaReason.EXPLICIT
            result.locked = True  # Auto-lock on switch
            result.message = f"Switched to {force_persona.value} mode (explicit)"

            logger.info(
                "Persona switch (forced)",
                extra={
                    "from": current_persona.value,
                    "to": force_persona.value,
                    "reason": "explicit_command",
                }
            )
            return result

        # Detect topics in message
        detection = self._detector.detect(message)

        # Handle explicit triggers (@security, @architect)
        if detection.explicit_trigger:
            target = detection.explicit_trigger

            if target == current_persona:
                result.message = f"Already in {current_persona.value} mode"
                return result

            if is_locked and detection.method == "explicit":
                # Explicit triggers work even when locked, but log it
                logger.warning(
                    "Explicit trigger overriding locked persona",
                    extra={
                        "from": current_persona.value,
                        "to": target.value,
                    }
                )

            result.switched = True
            result.persona = target
            result.reason = PersonaReason.EXPLICIT
            result.confidence = 1.0
            result.locked = True  # Auto-lock on switch
            result.message = f"Switched to {target.value} mode (@mention trigger)"

            logger.info(
                "Persona switch (explicit trigger)",
                extra={
                    "from": current_persona.value,
                    "to": target.value,
                    "trigger": detection.reasons[0] if detection.reasons else "explicit",
                }
            )
            return result

        # Handle detection-based switches (only if not locked)
        if is_locked:
            result.message = "Persona locked for this thread"
            return result

        suggested = detection.suggested_persona
        if suggested and suggested != current_persona:
            # Check thresholds
            confidence = (
                detection.security_score if suggested == PersonaName.SECURITY
                else detection.architect_score if suggested == PersonaName.ARCHITECT
                else 0.0
            )

            result.switched = True
            result.persona = suggested
            result.reason = PersonaReason.DETECTED
            result.confidence = confidence
            result.locked = True  # Auto-lock on switch
            result.message = f"Switched to {suggested.value} mode (detected: {', '.join(detection.reasons[:2])})"

            logger.info(
                "Persona switch (detected)",
                extra={
                    "from": current_persona.value,
                    "to": suggested.value,
                    "confidence": confidence,
                    "reasons": detection.reasons[:3],
                }
            )
            return result

        # No switch needed
        return result

    def apply_switch(
        self,
        state: dict[str, Any],
        switch_result: SwitchResult,
    ) -> dict[str, Any]:
        """Apply switch result to state.

        Returns partial state update for AgentState.
        """
        if not switch_result.switched:
            # Just increment message count
            return {
                "persona_message_count": state.get("persona_message_count", 0) + 1,
            }

        return {
            "persona": switch_result.persona.value,
            "persona_lock": switch_result.locked,
            "persona_reason": switch_result.reason.value,
            "persona_confidence": switch_result.confidence,
            "persona_changed_at": datetime.now(timezone.utc).isoformat(),
            "persona_message_count": 0,  # Reset on switch
        }

    def unlock(self, state: dict[str, Any]) -> dict[str, Any]:
        """Unlock persona for thread (allows re-detection).

        Returns partial state update.
        """
        logger.info(
            "Persona unlocked",
            extra={"current_persona": state.get("persona", "pm")}
        )
        return {"persona_lock": False}

    def lock(self, state: dict[str, Any]) -> dict[str, Any]:
        """Lock current persona for thread.

        Returns partial state update.
        """
        logger.info(
            "Persona locked",
            extra={"current_persona": state.get("persona", "pm")}
        )
        return {"persona_lock": True}
```
  </action>
  <verify>python -c "from src.personas.switcher import PersonaSwitcher, SwitchResult; s = PersonaSwitcher(); r = s.evaluate_switch('@security', PersonaName.PM, False); print(r.switched)" 2>/dev/null || python -c "from src.personas.switcher import PersonaSwitcher; from src.personas.types import PersonaName; s = PersonaSwitcher(); r = s.evaluate_switch('@security', PersonaName.PM, False); print(r.switched)"</verify>
  <done>PersonaSwitcher with evaluate_switch, apply_switch, lock/unlock</done>
</task>

<task type="auto">
  <name>Task 3: Update personas package exports</name>
  <files>src/personas/__init__.py</files>
  <action>
Update src/personas/__init__.py to export detector and switcher:

```python
"""Persona system - operational modes for the agent.

Personas are Policy + Lens (not "different chatbots"):
- prompt overlay: tone + priorities
- validation policy: extra checks to run
- tool preference: what to ask for, what to preview

Two orthogonal axes:
- persona controls voice and priorities
- validators control safety and correctness
"""
from src.personas.types import (
    PersonaName,
    PersonaReason,
    RiskTolerance,
    ValidatorSeverity,
    ValidatorFinding,
    ValidationFindings,
)
from src.personas.config import (
    PersonaConfig,
    PERSONAS,
    PERSONA_VALIDATORS,
    SILENT_VALIDATORS,
    SENSITIVE_OPS,
    get_persona,
    get_default_persona,
)
from src.personas.detector import (
    TopicDetector,
    DetectionResult,
    SECURITY_KEYWORDS,
    ARCHITECT_KEYWORDS,
)
from src.personas.switcher import (
    PersonaSwitcher,
    SwitchResult,
)

__all__ = [
    # Types
    "PersonaName",
    "PersonaReason",
    "RiskTolerance",
    "ValidatorSeverity",
    "ValidatorFinding",
    "ValidationFindings",
    # Config
    "PersonaConfig",
    "PERSONAS",
    "PERSONA_VALIDATORS",
    "SILENT_VALIDATORS",
    "SENSITIVE_OPS",
    "get_persona",
    "get_default_persona",
    # Detector
    "TopicDetector",
    "DetectionResult",
    "SECURITY_KEYWORDS",
    "ARCHITECT_KEYWORDS",
    # Switcher
    "PersonaSwitcher",
    "SwitchResult",
]
```
  </action>
  <verify>python -c "from src.personas import TopicDetector, PersonaSwitcher, DetectionResult, SwitchResult; print('ok')"</verify>
  <done>All detector and switcher exports added to package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.personas.detector import TopicDetector, DetectionResult"` succeeds
- [ ] `python -c "from src.personas.switcher import PersonaSwitcher, SwitchResult"` succeeds
- [ ] `python -c "from src.personas import TopicDetector, PersonaSwitcher"` succeeds
- [ ] Explicit @security trigger returns PersonaName.SECURITY
- [ ] Explicit @architect trigger returns PersonaName.ARCHITECT
- [ ] Heuristic detection scores security keywords correctly
- [ ] Auto-lock works on persona switch
- [ ] Unlock allows re-detection
</verification>

<success_criteria>

- TopicDetector with explicit trigger patterns and heuristic keyword matching
- DetectionResult with security_score, architect_score, reasons, explicit_trigger
- Security threshold 0.75, Architect threshold 0.60
- PersonaSwitcher with evaluate_switch, apply_switch, lock, unlock
- SwitchResult with switched, persona, reason, confidence, locked, message
- Auto-lock on any persona switch (prevents oscillation)
- Explicit triggers override lock (with warning log)
- All switching is auditable (logged)
</success_criteria>

<output>
After completion, create `.planning/phases/09-personas/09-02-SUMMARY.md`
</output>
