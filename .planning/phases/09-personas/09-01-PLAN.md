---
phase: 09-personas
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/personas/types.py, src/personas/config.py, src/personas/__init__.py, src/schemas/state.py]
autonomous: true
---

<objective>
Create persona definitions and config model with typed structures for PM, Security, and Architect personas.

Purpose: Foundation for persona system - define persona as Policy + Lens (prompt overlay + validation policy + tool preference).
Output: `PersonaConfig` model, `PERSONA_VALIDATORS` mapping, `SILENT_VALIDATORS` thresholds, AgentState persona fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-personas/09-CONTEXT.md

@src/schemas/state.py
@src/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persona types and enums</name>
  <files>src/personas/types.py</files>
  <action>
Create src/personas/types.py with persona enums and models:

```python
"""Persona type definitions.

Personas are operational modes (Policy + Lens), not "different chatbots".
Two orthogonal axes:
- persona â†’ presentation + emphasis (voice, priorities)
- validators â†’ risk detection + correctness (safety checks)
"""
from enum import Enum
from typing import Literal, Optional
from pydantic import BaseModel, Field


class PersonaName(str, Enum):
    """Available personas."""
    PM = "pm"
    SECURITY = "security"
    ARCHITECT = "architect"


class PersonaReason(str, Enum):
    """Why persona was activated."""
    DEFAULT = "default"      # PM is always default
    EXPLICIT = "explicit"    # User triggered (@security, /persona)
    DETECTED = "detected"    # Topic detection triggered


class RiskTolerance(str, Enum):
    """Persona risk tolerance level."""
    STRICT = "strict"        # Block on any concern
    MODERATE = "moderate"    # Warn but allow proceed


class ValidatorSeverity(str, Enum):
    """Validator finding severity."""
    BLOCK = "block"   # Must resolve before proceeding
    WARN = "warn"     # Should address but can proceed
    INFO = "info"     # Informational only


class ValidatorFinding(BaseModel):
    """Single finding from a validator."""
    id: str = Field(..., description="Finding ID for audit (e.g., SEC-RET-001)")
    severity: ValidatorSeverity
    message: str = Field(..., max_length=100, description="â‰¤1 line description")
    fix_hint: Optional[str] = Field(None, max_length=100, description="Optional fix suggestion")
    validator: str = Field(..., description="Which validator produced this")
    persona: PersonaName = Field(..., description="Which persona owns this validator")


class ValidationFindings(BaseModel):
    """Collection of findings from all validators."""
    findings: list[ValidatorFinding] = Field(default_factory=list)
    has_blocking: bool = False  # True if any BLOCK severity

    def add(self, finding: ValidatorFinding) -> None:
        """Add a finding."""
        self.findings.append(finding)
        if finding.severity == ValidatorSeverity.BLOCK:
            self.has_blocking = True

    def by_severity(self, severity: ValidatorSeverity) -> list[ValidatorFinding]:
        """Get findings by severity."""
        return [f for f in self.findings if f.severity == severity]

    def by_persona(self, persona: PersonaName) -> list[ValidatorFinding]:
        """Get findings by persona."""
        return [f for f in self.findings if f.persona == persona]
```
  </action>
  <verify>python -c "from src.personas.types import PersonaName, ValidatorFinding, ValidationFindings; print('ok')"</verify>
  <done>Persona types and validator finding models defined</done>
</task>

<task type="auto">
  <name>Task 2: Create persona config model</name>
  <files>src/personas/config.py</files>
  <action>
Create src/personas/config.py with persona definitions:

```python
"""Persona configuration - Policy + Lens definitions.

Each persona is a small overlay, not a giant prompt:
- name, goals (3-5 bullets)
- must_check validators
- questions_style, output_format
- risk_tolerance
"""
from dataclasses import dataclass, field
from typing import Optional

from src.personas.types import PersonaName, RiskTolerance


@dataclass(frozen=True)
class PersonaConfig:
    """Configuration for a single persona.

    Immutable config - persona behavior is deterministic.
    """
    name: PersonaName
    display_name: str
    emoji: str  # For subtle indicator on first 1-2 messages after switch
    goals: tuple[str, ...]  # 3-5 priority bullets
    must_check: tuple[str, ...]  # Validators that always run for this persona
    questions_style: str  # How this persona asks questions
    output_format: str  # How this persona formats responses
    risk_tolerance: RiskTolerance
    prompt_overlay: str  # Small prompt addition (not giant narrative)


# Persona validator mappings (two orthogonal mechanisms)
PERSONA_VALIDATORS: dict[PersonaName, tuple[str, ...]] = {
    PersonaName.PM: ("scope", "acceptance_criteria", "risks", "dependencies"),
    PersonaName.ARCHITECT: ("boundaries", "failure_modes", "idempotency", "scaling"),
    PersonaName.SECURITY: ("authz", "data_retention", "secrets", "least_privilege"),
}

# Silent validators - run based on topic detection (not persona switch)
SILENT_VALIDATORS: dict[str, dict] = {
    "security": {"threshold": 0.75, "validators": ("authz", "data_retention", "secrets")},
    "architect": {"threshold": 0.60, "validators": ("boundaries", "failure_modes")},
}

# Sensitive ops - always run Security validator regardless of detection
SENSITIVE_OPS: tuple[str, ...] = (
    "jira_create",
    "jira_update",
    "token_handling",
    "user_data_access",
    "content_storage",
    "channel_monitor",
)


# Persona definitions
PM_PERSONA = PersonaConfig(
    name=PersonaName.PM,
    display_name="Product Manager",
    emoji="ðŸ“‹",
    goals=(
        "Ensure requirements are clear and complete",
        "Identify missing acceptance criteria",
        "Flag scope risks and dependencies",
        "Prioritize user value",
        "Maintain timeline awareness",
    ),
    must_check=PERSONA_VALIDATORS[PersonaName.PM],
    questions_style="Focus on user stories and business value",
    output_format="Bullet lists with DoD section",
    risk_tolerance=RiskTolerance.MODERATE,
    prompt_overlay="""You are operating in PM mode. Prioritize:
- Clear problem statements
- Testable acceptance criteria
- Scope boundaries and dependencies
- User value and timeline risks""",
)

SECURITY_PERSONA = PersonaConfig(
    name=PersonaName.SECURITY,
    display_name="Security Analyst",
    emoji="ðŸ›¡ï¸",
    goals=(
        "Verify authorization model",
        "Check data retention policies",
        "Ensure least privilege access",
        "Validate audit trail requirements",
        "Flag secret/credential handling",
    ),
    must_check=PERSONA_VALIDATORS[PersonaName.SECURITY],
    questions_style="Direct questions about access, data, and permissions",
    output_format="Findings with severity and fix hints",
    risk_tolerance=RiskTolerance.STRICT,
    prompt_overlay="""You are operating in Security mode. Prioritize:
- Authorization and access control
- Data retention and privacy
- Secret management
- Audit trail and compliance""",
)

ARCHITECT_PERSONA = PersonaConfig(
    name=PersonaName.ARCHITECT,
    display_name="Technical Architect",
    emoji="ðŸ—ï¸",
    goals=(
        "Define system boundaries",
        "Identify failure modes",
        "Ensure idempotency where needed",
        "Plan for scaling requirements",
        "Specify observability needs",
    ),
    must_check=PERSONA_VALIDATORS[PersonaName.ARCHITECT],
    questions_style="Technical questions about design and failure cases",
    output_format="Architecture notes with trade-offs",
    risk_tolerance=RiskTolerance.MODERATE,
    prompt_overlay="""You are operating in Architect mode. Prioritize:
- Service boundaries and interfaces
- Failure modes and recovery
- Idempotency and consistency
- Scaling and observability""",
)


# Registry for lookup
PERSONAS: dict[PersonaName, PersonaConfig] = {
    PersonaName.PM: PM_PERSONA,
    PersonaName.SECURITY: SECURITY_PERSONA,
    PersonaName.ARCHITECT: ARCHITECT_PERSONA,
}


def get_persona(name: PersonaName) -> PersonaConfig:
    """Get persona configuration by name."""
    return PERSONAS[name]


def get_default_persona() -> PersonaConfig:
    """Get default persona (always PM)."""
    return PM_PERSONA
```
  </action>
  <verify>python -c "from src.personas.config import PERSONAS, get_persona, PersonaName; print(get_persona(PersonaName.SECURITY).emoji)"</verify>
  <done>PersonaConfig with PM, Security, Architect definitions and validator mappings</done>
</task>

<task type="auto">
  <name>Task 3: Add persona fields to AgentState</name>
  <files>src/schemas/state.py</files>
  <action>
Update AgentState in src/schemas/state.py to add persona tracking fields.

1. Add to imports:
```python
from typing import Literal, Optional, Annotated, Any, TYPE_CHECKING
from datetime import datetime
```

2. Add persona fields after channel_context field:

```python
    # Persona (Phase 9)
    persona: Optional[Literal["pm", "security", "architect"]]  # Current active persona
    persona_lock: bool  # If True, persona is locked for this thread
    persona_reason: Optional[Literal["default", "explicit", "detected"]]  # Why persona was set
    persona_confidence: Optional[float]  # Detection confidence (None for explicit/default)
    persona_changed_at: Optional[str]  # ISO timestamp of last persona change
    persona_message_count: int  # Messages since persona change (for indicator display)

    # Validator findings (Phase 9)
    validator_findings: Optional[dict[str, Any]]  # ValidationFindings.model_dump()
```

Place after `channel_context` and before `user_id`.
  </action>
  <verify>python -c "from src.schemas.state import AgentState; fields = AgentState.__annotations__; print('persona' in fields and 'persona_lock' in fields)"</verify>
  <done>AgentState has persona tracking fields</done>
</task>

<task type="auto">
  <name>Task 4: Create personas package exports</name>
  <files>src/personas/__init__.py</files>
  <action>
Create src/personas/__init__.py with package exports:

```python
"""Persona system - operational modes for the agent.

Personas are Policy + Lens (not "different chatbots"):
- prompt overlay: tone + priorities
- validation policy: extra checks to run
- tool preference: what to ask for, what to preview

Two orthogonal axes:
- persona controls voice and priorities
- validators control safety and correctness
"""
from src.personas.types import (
    PersonaName,
    PersonaReason,
    RiskTolerance,
    ValidatorSeverity,
    ValidatorFinding,
    ValidationFindings,
)
from src.personas.config import (
    PersonaConfig,
    PERSONAS,
    PERSONA_VALIDATORS,
    SILENT_VALIDATORS,
    SENSITIVE_OPS,
    get_persona,
    get_default_persona,
)

__all__ = [
    # Types
    "PersonaName",
    "PersonaReason",
    "RiskTolerance",
    "ValidatorSeverity",
    "ValidatorFinding",
    "ValidationFindings",
    # Config
    "PersonaConfig",
    "PERSONAS",
    "PERSONA_VALIDATORS",
    "SILENT_VALIDATORS",
    "SENSITIVE_OPS",
    "get_persona",
    "get_default_persona",
]
```
  </action>
  <verify>python -c "from src.personas import PersonaName, get_persona, SILENT_VALIDATORS; print('ok')"</verify>
  <done>Personas package with all exports</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.personas.types import PersonaName, ValidatorFinding"` succeeds
- [ ] `python -c "from src.personas.config import PERSONAS, PERSONA_VALIDATORS, SILENT_VALIDATORS"` succeeds
- [ ] `python -c "from src.personas import get_persona, PersonaName"` succeeds
- [ ] AgentState has persona, persona_lock, persona_reason, persona_confidence, persona_changed_at fields
- [ ] PM is default persona
- [ ] Security threshold is 0.75, Architect threshold is 0.60
</verification>

<success_criteria>

- PersonaConfig dataclass with name, goals, must_check, questions_style, output_format, risk_tolerance
- Three personas defined: PM, Security, Architect
- PERSONA_VALIDATORS maps persona â†’ required validators
- SILENT_VALIDATORS maps detector â†’ threshold + validators
- SENSITIVE_OPS lists operations that always trigger Security
- ValidatorFinding model with id, severity, message, fix_hint
- ValidationFindings collection with has_blocking, by_severity, by_persona helpers
- AgentState extended with persona tracking fields
</success_criteria>

<output>
After completion, create `.planning/phases/09-personas/09-01-SUMMARY.md`
</output>
