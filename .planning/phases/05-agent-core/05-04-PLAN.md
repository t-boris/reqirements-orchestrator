---
phase: 05-agent-core
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified: [src/graph/runner.py, src/graph/__init__.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Create graph runner and integrate with Slack handlers for interrupt/resume flow.

Purpose: Connect the PM-machine graph to Slack, enabling message processing and human-in-the-loop.
Output: Working graph runner that processes messages and handles ASK/PREVIEW interrupts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-core/05-CONTEXT.md
@.planning/phases/05-agent-core/05-01-SUMMARY.md
@.planning/phases/05-agent-core/05-02-SUMMARY.md
@.planning/phases/05-agent-core/05-03-SUMMARY.md

From CONTEXT.md:
- @mention triggers graph immediately
- Regular messages batch with debounce, then trigger
- New messages during run queue and wait (per-thread serialization from Phase 4)
- Graph can pause (interrupt) at ASK/PREVIEW, persist state, resume
- Uses session lock from 04-03

Integration points:
@src/slack/handlers.py
@src/slack/session.py
@src/slack/dedup.py
@src/slack/blocks.py
@src/graph/graph.py (after 05-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph runner with interrupt handling</name>
  <files>src/graph/runner.py</files>
  <action>
Create src/graph/runner.py:

```python
"""Graph runner - manages execution and interrupt/resume flow.

Handles:
- Session-based graph execution (one run per thread)
- Interrupt at ASK/PREVIEW for human-in-the-loop
- Resume with new messages
- State persistence via checkpointer
"""
import asyncio
import logging
from typing import Optional, Any
from datetime import datetime

from langchain_core.messages import HumanMessage

from src.schemas.state import AgentState, AgentPhase
from src.schemas.draft import TicketDraft
from src.graph.graph import get_compiled_graph
from src.slack.session import SessionIdentity, get_session_lock

logger = logging.getLogger(__name__)


class GraphRunner:
    """Manages graph execution for a session.

    One runner per thread - handles interrupt/resume flow.
    """

    def __init__(self, identity: SessionIdentity):
        self.identity = identity
        self.graph = get_compiled_graph()
        self._config = {
            "configurable": {
                "thread_id": identity.session_id,
            }
        }

    async def run_with_message(
        self,
        message_text: str,
        user_id: str,
    ) -> dict[str, Any]:
        """Run graph with new message.

        Adds message to state and runs until interrupt or completion.

        Returns:
            Result dict with:
            - action: "ask" | "preview" | "ready" | "continue" | "error"
            - questions: list[str] (if action=ask)
            - draft: TicketDraft (if action=preview)
            - error: str (if action=error)
        """
        async with get_session_lock(self.identity.session_id):
            try:
                # Get current state or initialize
                state = self._get_current_state()

                # Add new message
                new_message = HumanMessage(
                    content=message_text,
                    id=f"{self.identity.thread_ts}:{datetime.utcnow().isoformat()}",
                )
                state["messages"] = state.get("messages", []) + [new_message]

                # Update session context
                state["thread_ts"] = self.identity.thread_ts
                state["channel_id"] = self.identity.channel_id
                state["user_id"] = user_id

                # Run graph
                result_state = await self._run_until_interrupt(state)

                # Interpret result
                return self._interpret_result(result_state)

            except Exception as e:
                logger.error(f"Graph run failed: {e}", exc_info=True)
                return {"action": "error", "error": str(e)}

    def _get_current_state(self) -> AgentState:
        """Get current state from checkpointer or initialize new."""
        try:
            checkpoint = self.graph.get_state(self._config)
            if checkpoint and checkpoint.values:
                return dict(checkpoint.values)
        except Exception as e:
            logger.debug(f"No existing state: {e}")

        # Initialize new state
        return {
            "messages": [],
            "draft": TicketDraft(epic_id=None),
            "phase": AgentPhase.COLLECTING,
            "step_count": 0,
            "thread_ts": self.identity.thread_ts,
            "channel_id": self.identity.channel_id,
            "user_id": None,
            "validation_report": {},
            "decision_result": {},
        }

    async def _run_until_interrupt(self, state: AgentState) -> AgentState:
        """Run graph until interrupt point or completion.

        Interrupt points:
        - ASK: Need user input
        - PREVIEW: Show draft for approval
        - READY_TO_CREATE: Approved, ready for Jira (Phase 7)
        """
        # Stream through graph
        async for event in self.graph.astream(state, self._config):
            # Check for interrupt conditions
            current_state = event.get(list(event.keys())[0], {}) if event else {}

            decision_result = current_state.get("decision_result", {})
            action = decision_result.get("action")

            if action in ["ask", "preview", "ready_to_create"]:
                # Interrupt - return current state
                logger.info(f"Graph interrupted at {action}")
                return self._merge_state(state, current_state)

        # Graph completed
        final_state = self.graph.get_state(self._config)
        return dict(final_state.values) if final_state else state

    def _merge_state(self, base: AgentState, updates: dict) -> AgentState:
        """Merge state updates into base state."""
        result = dict(base)
        for key, value in updates.items():
            if value is not None:
                result[key] = value
        return result

    def _interpret_result(self, state: AgentState) -> dict[str, Any]:
        """Convert final state to action result."""
        decision_result = state.get("decision_result", {})
        action = decision_result.get("action", "continue")

        if action == "ask":
            return {
                "action": "ask",
                "questions": decision_result.get("questions", []),
                "reason": decision_result.get("reason", ""),
            }
        elif action == "preview":
            return {
                "action": "preview",
                "draft": state.get("draft"),
                "reason": decision_result.get("reason", ""),
            }
        elif action == "ready_to_create":
            return {
                "action": "ready",
                "draft": state.get("draft"),
            }
        else:
            return {"action": "continue"}

    async def handle_approval(self, approved: bool) -> dict[str, Any]:
        """Handle user approval of preview.

        If approved, set phase to READY_TO_CREATE.
        If rejected, return to COLLECTING.
        """
        async with get_session_lock(self.identity.session_id):
            state = self._get_current_state()

            if approved:
                state["phase"] = AgentPhase.READY_TO_CREATE
                # Save state
                await self.graph.aupdate_state(self._config, state)
                return {"action": "ready", "draft": state.get("draft")}
            else:
                state["phase"] = AgentPhase.COLLECTING
                await self.graph.aupdate_state(self._config, state)
                return {"action": "continue"}


# Session runner cache
_runners: dict[str, GraphRunner] = {}


def get_runner(identity: SessionIdentity) -> GraphRunner:
    """Get or create runner for session."""
    if identity.session_id not in _runners:
        _runners[identity.session_id] = GraphRunner(identity)
    return _runners[identity.session_id]


def cleanup_runner(session_id: str) -> None:
    """Clean up runner when session ends."""
    if session_id in _runners:
        del _runners[session_id]
        logger.debug(f"Cleaned up runner for {session_id}")
```
  </action>
  <verify>python -c "from src.graph.runner import GraphRunner, get_runner; print('runner ok')"</verify>
  <done>Graph runner with interrupt handling and session management</done>
</task>

<task type="auto">
  <name>Task 2: Update Slack handlers to use graph runner</name>
  <files>src/slack/handlers.py</files>
  <action>
Update src/slack/handlers.py to integrate with graph runner:

1. In handle_app_mention: Create session identity, get runner, run with message
2. In handle_message (thread): Check if session is active, run with message
3. Add helper to format and send ASK questions
4. Add helper to format and send PREVIEW with approval buttons

Key changes:
```python
# Add imports
from src.graph.runner import get_runner

# In handle_app_mention:
async def _process_mention(event: dict, client: WebClient, context: BoltContext):
    """Async processing for @mention - runs graph."""
    team_id = context.get("team_id", "")
    channel = event.get("channel")
    thread_ts = event.get("thread_ts") or event.get("ts")
    user = event.get("user")
    text = event.get("text", "")

    identity = SessionIdentity(
        team_id=team_id,
        channel_id=channel,
        thread_ts=thread_ts,
    )

    runner = get_runner(identity)
    result = await runner.run_with_message(text, user)

    # Handle result
    if result["action"] == "ask":
        # Format questions as bullet list
        questions_text = "I need a bit more information:\n"
        for q in result["questions"]:
            questions_text += f"• {q}\n"
        client.chat_postMessage(
            channel=channel,
            thread_ts=thread_ts,
            text=questions_text,
        )
    elif result["action"] == "preview":
        # Show preview with approval buttons
        from src.slack.blocks import build_draft_preview_blocks
        blocks = build_draft_preview_blocks(result["draft"])
        client.chat_postMessage(
            channel=channel,
            thread_ts=thread_ts,
            text="Here's the ticket preview:",
            blocks=blocks,
        )
    elif result["action"] == "ready":
        client.chat_postMessage(
            channel=channel,
            thread_ts=thread_ts,
            text="Ticket approved and ready to create in Jira!",
        )
```

Make handle_app_mention call _process_mention via asyncio.create_task() to maintain fast-ack pattern.

Also add action handler for draft approval buttons (approve_draft / reject_draft).
  </action>
  <verify>python -c "from src.slack.handlers import handle_app_mention; print('handlers ok')"</verify>
  <done>Slack handlers integrated with graph runner</done>
</task>

<task type="auto">
  <name>Task 3: Add draft preview blocks to blocks.py</name>
  <files>src/slack/blocks.py</files>
  <action>
Add to src/slack/blocks.py:

```python
def build_draft_preview_blocks(draft: "TicketDraft") -> list[dict]:
    """Build Slack blocks for ticket draft preview.

    Shows all draft fields with approval buttons.
    """
    from src.schemas.draft import TicketDraft

    blocks = []

    # Header
    blocks.append({
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": "Ticket Preview",
            "emoji": True
        }
    })

    # Title
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"*Title:* {draft.title or '_Not set_'}"
        }
    })

    # Problem
    blocks.append({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": f"*Problem:*\n{draft.problem or '_Not set_'}"
        }
    })

    # Solution (if present)
    if draft.proposed_solution:
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Proposed Solution:*\n{draft.proposed_solution}"
            }
        })

    # Acceptance Criteria
    if draft.acceptance_criteria:
        ac_text = "*Acceptance Criteria:*\n"
        for i, ac in enumerate(draft.acceptance_criteria, 1):
            ac_text += f"{i}. {ac}\n"
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": ac_text
            }
        })

    # Constraints (if present)
    if draft.constraints:
        constraints_text = "*Constraints:*\n"
        for c in draft.constraints:
            constraints_text += f"• `{c.key}` = `{c.value}` ({c.status})\n"
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": constraints_text
            }
        })

    # Divider
    blocks.append({"type": "divider"})

    # Approval buttons
    blocks.append({
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Approve & Create",
                    "emoji": True
                },
                "value": draft.id,
                "action_id": "approve_draft",
                "style": "primary",
            },
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Needs Changes",
                    "emoji": True
                },
                "value": draft.id,
                "action_id": "reject_draft",
            },
        ]
    })

    # Context
    blocks.append({
        "type": "context",
        "elements": [{
            "type": "mrkdwn",
            "text": f"Draft version {draft.version} | {len(draft.evidence_links)} evidence links"
        }]
    })

    return blocks
```
  </action>
  <verify>python -c "from src.slack.blocks import build_draft_preview_blocks; print('preview blocks ok')"</verify>
  <done>Draft preview blocks with approval buttons</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.graph.runner import GraphRunner, get_runner"` succeeds
- [ ] `python -c "from src.slack.blocks import build_draft_preview_blocks"` succeeds
- [ ] Graph runner handles ASK/PREVIEW/READY actions
- [ ] Slack handlers use session lock for thread serialization
- [ ] Draft preview shows all fields with approval buttons
- [ ] No import errors
</verification>

<success_criteria>

- All tasks completed
- Graph runner manages interrupt/resume flow
- Slack handlers integrated with graph runner
- ASK action posts questions to thread
- PREVIEW action shows draft with approval buttons
- Per-thread serialization via session locks
- DoD Scenario 1: Enough data -> PREVIEW -> approval -> READY_TO_CREATE works
- DoD Scenario 2: Not enough data -> ASK -> interrupt -> resume works
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-core/05-04-SUMMARY.md`
</output>
