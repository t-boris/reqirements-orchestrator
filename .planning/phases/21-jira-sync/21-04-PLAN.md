---
phase: 21-jira-sync
plan: 04
type: execute
wave: 3
depends_on: [21-01, 21-02, 21-03]
files_modified: [src/slack/sync_engine.py, src/slack/handlers/commands.py, src/slack/handlers/sync.py]
autonomous: true
---

<objective>
Create smart sync engine for bidirectional Jira synchronization.

Purpose: "@Maro update Jira issues" triggers smart sync - finds delta between channel decisions and Jira, applies obvious updates automatically, asks about conflicts.
Output: SyncEngine that detects changes and handles conflicts intelligently.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-jira-sync/21-CONTEXT.md

@src/slack/channel_tracker.py (from 21-01)
@src/slack/pinned_board.py (from 21-02)
@src/jira/client.py
@src/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncEngine with change detection</name>
  <files>src/slack/sync_engine.py</files>
  <action>
Create SyncEngine class that detects changes between Slack decisions and Jira state.

Class: SyncEngine

Data models:
```python
@dataclass
class ChangeDetection:
    issue_key: str
    field: str
    slack_value: Optional[str]  # What channel decided
    jira_value: Optional[str]   # Current Jira state
    change_type: Literal["slack_ahead", "jira_ahead", "conflict", "in_sync"]
    confidence: float  # How confident we are about the change
    source: str  # Where we detected the slack_value (e.g., "thread:1234", "decision:5678")

@dataclass
class SyncPlan:
    auto_apply: list[ChangeDetection]  # High confidence, obvious updates
    needs_review: list[ChangeDetection]  # Conflicts or low confidence
    in_sync: list[str]  # Issue keys already in sync
```

Methods:
- detect_changes(channel_id) -> SyncPlan
  1. Get all tracked issues from ChannelIssueTracker
  2. Fetch current state from Jira for each
  3. Compare against stored last_jira_* values
  4. Scan channel history for decisions/changes (architecture decisions, explicit commands)
  5. Categorize each change

- apply_changes(changes: list[ChangeDetection]) -> list[SyncResult]
  1. For each change, update Jira
  2. Update tracker with new values
  3. Return success/failure for each

Change detection sources:
- Architecture decisions (Phase 14 "Approve & Post Decision")
- Explicit commands ("change priority to high")
- Thread discussions with ticket mentions
  </action>
  <verify>SyncEngine.detect_changes returns categorized changes</verify>
  <done>SyncEngine detects differences between Slack and Jira</done>
</task>

<task type="auto">
  <name>Task 2: Add /maro sync command</name>
  <files>src/slack/handlers/commands.py, src/slack/handlers/sync.py</files>
  <action>
Add sync subcommand to /maro:
- `/maro sync` - Detect and show pending changes
- `/maro sync --auto` - Apply obvious changes automatically

In _handle_maro_command_async:
```python
elif text.startswith("sync"):
    auto_mode = "--auto" in text
    await _handle_maro_sync(channel, client, user_id, auto_mode)
```

Create src/slack/handlers/sync.py:

Function: handle_maro_sync
1. Run SyncEngine.detect_changes()
2. If no changes: "All tracked issues are in sync with Jira"
3. If changes found, build summary blocks:
   ```
   ðŸ“Š *Jira Sync for #channel*

   *Auto-apply (2 changes)*
   These will be applied automatically:
   â€¢ SCRUM-123: priority Medium â†’ High (from architecture decision)
   â€¢ SCRUM-124: status To Do â†’ In Progress (explicit command)

   *Needs Review (1 conflict)*
   â€¢ SCRUM-125: description
     - Slack: "New requirements added"
     - Jira: "Different text from someone else"
     [Use Slack] [Use Jira] [Skip]

   [Apply Auto Changes] [Review All] [Cancel]
   ```

4. If --auto mode, apply auto_apply changes immediately
5. Post results
  </action>
  <verify>/maro sync shows pending changes summary</verify>
  <done>Sync command shows changes and allows bulk apply</done>
</task>

<task type="auto">
  <name>Task 3: Build conflict resolution UI</name>
  <files>src/slack/handlers/sync.py, src/slack/router.py</files>
  <action>
Create interactive conflict resolution flow.

When conflict detected, show side-by-side:
```
âš ï¸ *Conflict: SCRUM-125 description*

*Slack version* (from thread Jan 15):
> The user authentication should support OAuth2 and JWT tokens.

*Jira version* (updated Jan 16 by @sarah):
> Authentication will use OAuth2 only. JWT support deferred.

[Use Slack Version] [Use Jira Version] [Merge...] [Skip]
```

Button handlers in router.py:
- sync_use_slack: Apply Slack value to Jira
- sync_use_jira: Keep Jira value (update tracker to match)
- sync_merge: Open modal for manual merge
- sync_skip: Skip this conflict, continue with others

Modal for merge:
- Show both versions side by side
- Text input for merged content
- [Save Merged Version] [Cancel]

After resolution:
- Update Jira if Slack version chosen
- Update tracker with final value
- Move to next conflict or show completion summary
  </action>
  <verify>Conflict shows both versions, resolution buttons work</verify>
  <done>Conflict resolution UI with side-by-side comparison</done>
</task>

<task type="auto">
  <name>Task 4: Add sync trigger on "@Maro update Jira"</name>
  <files>src/graph/intent.py, src/graph/nodes/sync_trigger.py, src/slack/handlers/dispatch.py</files>
  <action>
Make "@Maro update Jira issues" trigger sync naturally.

1. In intent.py, add SYNC_REQUEST intent:
   - "update Jira issues"
   - "sync Jira"
   - "update the tickets"
   - "sync everything"

2. Create src/graph/nodes/sync_trigger.py:
   - Detect sync request
   - Return action="sync_request"

3. In dispatch.py, add handler:
   ```python
   elif action == "sync_request":
       # Run sync analysis
       from src.slack.sync_engine import SyncEngine
       engine = SyncEngine()
       plan = await engine.detect_changes(identity.channel_id)

       # Build and post sync summary (same as /maro sync)
       await _handle_sync_summary(plan, identity, client)
   ```

This makes natural language sync work: "@Maro update Jira issues" â†’ sync flow.
  </action>
  <verify>"@Maro update Jira" triggers sync analysis</verify>
  <done>Natural language triggers sync flow</done>
</task>

<task type="auto">
  <name>Task 5: Track decisions as sync sources</name>
  <files>src/slack/handlers/dispatch.py, src/db/models.py</files>
  <action>
Store decisions that should sync to Jira.

Add model: ChannelDecision
- channel_id: str
- decision_ts: str (Slack message timestamp)
- topic: str
- decision_text: str
- related_issues: list[str] (Jira keys mentioned or linked)
- synced_to_jira: bool
- synced_at: Optional[datetime]

In _handle_decision_approval (dispatch.py):
1. After posting decision to channel
2. Extract any Jira issue keys mentioned
3. Store as ChannelDecision with synced_to_jira=False
4. These become sources for SyncEngine.detect_changes()

Sync detection:
- Query ChannelDecision where synced_to_jira=False
- Match decisions to tracked issues by key
- Suggest adding decision to issue description/comment
  </action>
  <verify>Approved decision stored, appears in sync detection</verify>
  <done>Architecture decisions tracked as sync sources</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.slack.sync_engine import SyncEngine"` works
- [ ] /maro sync shows pending changes
- [ ] Auto-apply changes update Jira
- [ ] Conflicts show side-by-side comparison
- [ ] "@Maro update Jira" triggers sync
- [ ] Architecture decisions appear in sync sources
</verification>

<success_criteria>

- All tasks completed
- SyncEngine detects changes between Slack and Jira
- /maro sync shows categorized changes
- Auto-apply for obvious changes
- Conflict resolution with side-by-side UI
- Natural language sync triggers
- Decisions tracked as sync sources
</success_criteria>

<output>
After completion, create `.planning/phases/21-jira-sync/21-04-SUMMARY.md`
</output>
