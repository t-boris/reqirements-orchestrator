---
phase: 07-jira-integration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified: [src/skills/jira_create.py, src/skills/__init__.py, src/db/jira_operations.py, src/slack/handlers.py]
autonomous: true
---

<objective>
Build jira_create skill with strict approval validation, idempotency, audit trail, and all-or-nothing transactional semantics.

Purpose: This is the most dangerous skill - it creates real Jira tickets. Every guard must pass before create.
Output: `jira_create()` skill that only executes after approval validation, writes audit trail, updates session state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-jira-integration/07-CONTEXT.md
@.planning/phases/07-jira-integration/07-01-SUMMARY.md

@src/jira/client.py
@src/jira/types.py
@src/db/approval_store.py
@src/skills/preview_ticket.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jira operations table for idempotency</name>
  <files>src/db/jira_operations.py</files>
  <action>
Create PostgreSQL store for Jira operation idempotency and audit trail:

```sql
CREATE TABLE IF NOT EXISTS jira_operations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id TEXT NOT NULL,
    draft_hash TEXT NOT NULL,
    operation TEXT NOT NULL,  -- 'jira_create', 'jira_update'
    jira_key TEXT,  -- Resulting issue key (PROJ-123)
    created_by TEXT NOT NULL,  -- User who triggered
    approved_by TEXT NOT NULL,  -- User who approved (from approval record)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    status TEXT DEFAULT 'pending',  -- pending, success, failed
    error_message TEXT,
    UNIQUE(session_id, draft_hash, operation)
);
```

Create `JiraOperationStore` class:
1. `record_operation_start()` - Insert pending record, return True if new (first wins)
2. `mark_success(jira_key)` - Update status to success, store jira_key
3. `mark_failed(error)` - Update status to failed, store error
4. `get_operation()` - Get operation record if exists
5. `was_already_created()` - Check if operation succeeded (for idempotency)

This is the idempotency key: `(session_id, draft_hash, "jira_create")`.
Unique constraint prevents duplicate creates from Slack retries.
  </action>
  <verify>python -c "from src.db.jira_operations import JiraOperationStore; print('ok')"</verify>
  <done>jira_operations table with unique constraint, JiraOperationStore class</done>
</task>

<task type="auto">
  <name>Task 2: Implement jira_create skill</name>
  <files>src/skills/jira_create.py, src/skills/__init__.py</files>
  <action>
Create jira_create skill with strict validation pipeline:

```python
@dataclass
class JiraCreateResult:
    success: bool
    jira_key: Optional[str] = None
    jira_url: Optional[str] = None
    error: Optional[str] = None
    was_duplicate: bool = False  # True if already created (idempotent)

async def jira_create(
    session_id: str,
    draft: TicketDraft,
    approved_by: str,
    approval_id: str,
    jira_service: JiraService,
    conn: AsyncConnection,
) -> JiraCreateResult:
```

**Pipeline (all-or-nothing):**

1. **Validate approval exists:**
   ```python
   approval_store = ApprovalStore(conn)
   approval = await approval_store.get_approval(session_id, compute_draft_hash(draft))
   if not approval:
       return JiraCreateResult(success=False, error="No approval record found")
   ```

2. **Check draft_hash matches:**
   ```python
   current_hash = compute_draft_hash(draft)
   if current_hash != approval.draft_hash:
       return JiraCreateResult(success=False, error="Draft changed since approval. Please re-approve.")
   ```

3. **Check idempotency (first wins):**
   ```python
   op_store = JiraOperationStore(conn)
   if await op_store.was_already_created(session_id, current_hash):
       existing = await op_store.get_operation(session_id, current_hash, "jira_create")
       return JiraCreateResult(
           success=True,
           jira_key=existing.jira_key,
           jira_url=f"{settings.jira_url}/browse/{existing.jira_key}",
           was_duplicate=True
       )

   # Try to claim this operation
   is_new = await op_store.record_operation_start(
       session_id, current_hash, "jira_create",
       created_by=approved_by, approved_by=approval.approved_by
   )
   if not is_new:
       # Race condition - another process already claimed it
       return JiraCreateResult(success=False, error="Operation already in progress")
   ```

4. **Create Jira issue:**
   ```python
   try:
       request = JiraCreateRequest(
           project_key=settings.jira_default_project,
           summary=draft.title,
           description=_format_description(draft),
           issue_type=JiraIssueType.STORY,
           priority=_map_priority(draft),  # Use priority from draft or default MEDIUM
       )
       issue = await jira_service.create_issue(request)
       await op_store.mark_success(session_id, current_hash, "jira_create", issue.key)
       return JiraCreateResult(success=True, jira_key=issue.key, jira_url=issue.url)
   except JiraAPIError as e:
       await op_store.mark_failed(session_id, current_hash, "jira_create", str(e))
       return JiraCreateResult(success=False, error=f"Jira API error: {e.message}")
   ```

**All-or-nothing:** If Jira create fails, session state does NOT advance (handled by caller).

Helper functions:
- `_format_description(draft)` - Format problem, solution, ACs into Jira description
- `_map_priority(draft)` - Map draft priority (if exists) to JiraPriority enum
  </action>
  <verify>python -c "from src.skills.jira_create import jira_create, JiraCreateResult; print('ok')"</verify>
  <done>jira_create skill with full validation pipeline, idempotency, audit trail</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with approval handler</name>
  <files>src/slack/handlers.py</files>
  <action>
Update handle_approve_draft to call jira_create after approval:

```python
async def handle_approve_draft(ack, body, client: WebClient, action):
    ack()

    # ... existing approval logic ...

    # After approval succeeds, create Jira ticket
    result = await jira_create(
        session_id=identity.session_id,
        draft=state.get("draft"),
        approved_by=body["user"]["id"],
        approval_id=...,
        jira_service=get_jira_service(),
        conn=conn,
    )

    if result.success:
        if result.was_duplicate:
            # Already created - just notify
            client.chat_postMessage(
                channel=channel,
                thread_ts=thread_ts,
                text=f"Ticket was already created: <{result.jira_url}|{result.jira_key}>",
            )
        else:
            # New creation - update session state, notify with link
            await runner.update_state({"phase": AgentPhase.CREATED, "jira_key": result.jira_key})
            client.chat_postMessage(
                channel=channel,
                thread_ts=thread_ts,
                text=f"Ticket created: <{result.jira_url}|{result.jira_key}>",
            )
            # Update preview message to show created state
            _update_preview_to_created(client, channel, message_ts, result.jira_key)
    else:
        # Creation failed - don't advance state, notify error
        client.chat_postMessage(
            channel=channel,
            thread_ts=thread_ts,
            text=f"Could not create ticket: {result.error}",
        )
```

Add helper `_update_preview_to_created()`:
- Update original preview message to show "Created: PROJ-123" with link
- Remove approval buttons
- Add context: "Created by @user at TIME"
  </action>
  <verify>python -c "from src.slack.handlers import handle_approve_draft; print('ok')"</verify>
  <done>Approval handler creates Jira ticket, updates Slack UI, handles errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.skills.jira_create import jira_create, JiraCreateResult"` succeeds
- [ ] `python -c "from src.db.jira_operations import JiraOperationStore"` succeeds
- [ ] jira_operations table has unique constraint on (session_id, draft_hash, operation)
- [ ] Approval validation checks draft_hash match
- [ ] Idempotency key prevents duplicate creates
</verification>

<success_criteria>

- jira_create requires approval (validation fails without it)
- Draft hash validation blocks drift
- Idempotent (duplicate requests return existing ticket)
- Audit trail in jira_operations table
- All-or-nothing: Jira failure doesn't advance session state
- Slack UI updated after create
</success_criteria>

<output>
After completion, create `.planning/phases/07-jira-integration/07-02-SUMMARY.md`
</output>
