---
phase: 07-jira-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/jira/__init__.py, src/jira/client.py, src/jira/types.py, src/config/settings.py]
autonomous: true
---

<objective>
Build Jira API client as a service with policy (not a library wrapper).

Purpose: Foundation for jira_create and jira_search skills with retry/backoff, dry-run mode, environment separation, and logging.
Output: JiraService class with create_issue(), search_issues() methods ready for skill layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-jira-integration/07-CONTEXT.md

@src/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jira types and priority mapping</name>
  <files>src/jira/__init__.py, src/jira/types.py</files>
  <action>
Create Jira package with types:

1. `JiraIssueType` enum: STORY, TASK, BUG, EPIC
2. `JiraPriority` enum: LOW, MEDIUM, HIGH, CRITICAL (internal logical values)
3. `PRIORITY_MAP` dict mapping internal to Jira values:
   - LOW → "Lowest"
   - MEDIUM → "Medium"
   - HIGH → "High"
   - CRITICAL → "Highest"
4. `JiraIssue` Pydantic model (response):
   - key: str (PROJ-123)
   - summary: str
   - status: str
   - assignee: Optional[str]
   - url: str (computed from base_url + key)
5. `JiraCreateRequest` Pydantic model (request):
   - project_key: str
   - summary: str
   - description: str
   - issue_type: JiraIssueType
   - priority: JiraPriority
   - epic_key: Optional[str]
   - labels: list[str] = []

NEVER hardcode Jira priority strings in business logic - always go through PRIORITY_MAP.
  </action>
  <verify>python -c "from src.jira.types import JiraIssue, JiraCreateRequest, PRIORITY_MAP; print('ok')"</verify>
  <done>Types defined, priority mapping table exists</done>
</task>

<task type="auto">
  <name>Task 2: Add environment settings</name>
  <files>src/config/settings.py</files>
  <action>
Add Jira environment settings to Settings class:

1. `jira_env: str = "dev"` - Environment identifier (dev|staging|prod)
2. `jira_dry_run: bool = False` - When True, log instead of calling Jira API
3. `jira_timeout: int = 30` - Request timeout in seconds
4. `jira_max_retries: int = 3` - Max retry attempts for transient failures

Note: jira_url, jira_user, jira_api_token already exist in settings.py.
  </action>
  <verify>python -c "from src.config.settings import get_settings; s = get_settings(); print(f'env={s.jira_env}, dry_run={s.jira_dry_run}')"</verify>
  <done>Environment settings loadable from .env</done>
</task>

<task type="auto">
  <name>Task 3: Implement JiraService client</name>
  <files>src/jira/client.py, src/jira/__init__.py</files>
  <action>
Create JiraService class (service pattern, not library wrapper):

```python
class JiraService:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.base_url = settings.jira_url
        self.auth = (settings.jira_user, settings.jira_api_token)
        self._session: Optional[aiohttp.ClientSession] = None
```

Methods:
1. `async def create_issue(request: JiraCreateRequest) -> JiraIssue`:
   - Check dry_run mode first (log payload, return mock issue)
   - Build API payload with PRIORITY_MAP for priority value
   - POST to /rest/api/3/issue
   - Retry with exponential backoff on 5xx errors
   - Raise JiraAPIError on 4xx errors
   - Log: payload, response, timing

2. `async def search_issues(jql: str, limit: int = 5) -> list[JiraIssue]`:
   - GET /rest/api/3/search with JQL parameter
   - Return list of JiraIssue models
   - Log: query, result count, timing

3. `async def get_issue(key: str) -> JiraIssue`:
   - GET /rest/api/3/issue/{key}
   - Return JiraIssue model

Helper:
- `_request()` internal method with:
  - aiohttp session management
  - Auth header (Basic auth from token)
  - Content-Type: application/json
  - Retry logic (exponential backoff, max_retries from settings)
  - Timeout from settings
  - Structured logging (request, response, duration)

Error handling:
- `JiraAPIError` exception class with status_code, message, response_body
- Raise on 4xx (client error, no retry)
- Retry on 5xx (server error, transient)
- Raise on timeout after all retries exhausted
  </action>
  <verify>python -c "from src.jira.client import JiraService; print('client ok')"</verify>
  <done>JiraService class with create_issue, search_issues, retry/backoff, dry-run mode</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.jira import JiraService, JiraIssue, JiraCreateRequest"` succeeds
- [ ] `python -c "from src.jira.types import PRIORITY_MAP; print(PRIORITY_MAP)"` shows mapping
- [ ] Settings include jira_env, jira_dry_run, jira_timeout, jira_max_retries
- [ ] JiraService has create_issue, search_issues, get_issue methods
</verification>

<success_criteria>

- JiraService works as service with policy (not library wrapper)
- Dry-run mode logs instead of calling API
- Environment separation via jira_env setting
- Retry/backoff for transient failures
- Structured logging for all operations
</success_criteria>

<output>
After completion, create `.planning/phases/07-jira-integration/07-01-SUMMARY.md`
</output>
