---
phase: 16-ticket-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jira/client.py
  - src/slack/handlers.py
autonomous: true
---

<objective>
Implement ticket operations: update, add_comment, create_subtask.

Purpose: Replace stubs from Phase 13.1 with real Jira API calls. Users can now update tickets, add comments, and create subtasks by referencing existing tickets.

Output:
- Three new JiraService methods: `update_issue()`, `add_comment()`, `create_subtask()`
- Handler dispatch replaces stubs with real API calls
- Content extraction prompts for update/comment operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/16-ticket-operations/16-CONTEXT.md
@src/jira/client.py
@src/jira/types.py
@src/slack/handlers.py
@src/graph/nodes/ticket_action.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add update_issue method to JiraService</name>
  <files>src/jira/client.py</files>
  <action>
Add `update_issue()` method to JiraService class after `get_issue()`:

```python
async def update_issue(
    self,
    issue_key: str,
    updates: dict[str, Any],
    progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
) -> JiraIssue:
    """Update a Jira issue with field changes.

    Uses PUT /rest/api/3/issue/{issueIdOrKey} endpoint.

    Args:
        issue_key: Issue key (e.g., "SCRUM-111")
        updates: Fields to update. Supports:
            - "description": Text (will be converted to ADF)
            - "summary": Plain text
            - "priority": {"name": "High"}
            - "labels": ["label1", "label2"]
        progress_callback: Optional retry visibility callback

    Returns:
        Updated JiraIssue with refreshed fields

    Raises:
        JiraAPIError: On API errors
    """
    logger.info(
        "Updating Jira issue",
        extra={
            "issue_key": issue_key,
            "update_fields": list(updates.keys()),
            "jira_env": self.settings.jira_env,
        },
    )

    # Convert description to ADF if present
    if "description" in updates and isinstance(updates["description"], str):
        updates["description"] = {
            "type": "doc",
            "version": 1,
            "content": [
                {
                    "type": "paragraph",
                    "content": [{"type": "text", "text": updates["description"]}],
                }
            ],
        }

    payload = {"fields": updates}

    # Dry-run mode
    if self.settings.jira_dry_run:
        logger.info(
            "Dry-run mode: would update issue",
            extra={"issue_key": issue_key, "payload": payload},
        )
        return await self.get_issue(issue_key)

    await self._request(
        "PUT",
        f"/rest/api/3/issue/{issue_key}",
        json_data=payload,
        progress_callback=progress_callback,
    )

    logger.info(
        "Jira issue updated successfully",
        extra={"issue_key": issue_key},
    )

    # Return refreshed issue
    return await self.get_issue(issue_key)
```
  </action>
  <verify>python -c "from src.jira.client import JiraService; print('update_issue' in dir(JiraService))"</verify>
  <done>update_issue method exists and handles ADF conversion</done>
</task>

<task type="auto">
  <name>Task 2: Add add_comment method to JiraService</name>
  <files>src/jira/client.py</files>
  <action>
Add `add_comment()` method to JiraService class after `update_issue()`:

```python
async def add_comment(
    self,
    issue_key: str,
    comment: str,
    progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
) -> dict[str, Any]:
    """Add comment to a Jira issue.

    Uses POST /rest/api/3/issue/{issueIdOrKey}/comment endpoint.

    Args:
        issue_key: Issue key (e.g., "SCRUM-111")
        comment: Comment text (plain text, will be converted to ADF)
        progress_callback: Optional retry visibility callback

    Returns:
        Created comment response with id, author, body, created timestamp

    Raises:
        JiraAPIError: On API errors
    """
    logger.info(
        "Adding comment to Jira issue",
        extra={
            "issue_key": issue_key,
            "comment_length": len(comment),
            "jira_env": self.settings.jira_env,
        },
    )

    # Convert plain text to ADF
    payload = {
        "body": {
            "type": "doc",
            "version": 1,
            "content": [
                {
                    "type": "paragraph",
                    "content": [{"type": "text", "text": comment}],
                }
            ],
        }
    }

    # Dry-run mode
    if self.settings.jira_dry_run:
        logger.info(
            "Dry-run mode: would add comment",
            extra={"issue_key": issue_key, "comment_preview": comment[:100]},
        )
        return {"id": "dry-run", "body": payload["body"]}

    response = await self._request(
        "POST",
        f"/rest/api/3/issue/{issue_key}/comment",
        json_data=payload,
        progress_callback=progress_callback,
    )

    logger.info(
        "Comment added successfully",
        extra={
            "issue_key": issue_key,
            "comment_id": response.get("id"),
        },
    )

    return response
```
  </action>
  <verify>python -c "from src.jira.client import JiraService; print('add_comment' in dir(JiraService))"</verify>
  <done>add_comment method exists and converts text to ADF</done>
</task>

<task type="auto">
  <name>Task 3: Add create_subtask method to JiraService</name>
  <files>src/jira/client.py</files>
  <action>
Add `create_subtask()` method to JiraService class after `add_comment()`:

```python
async def create_subtask(
    self,
    parent_key: str,
    summary: str,
    description: str = "",
    progress_callback: Optional[Callable[[str, int, int], Awaitable[None]]] = None,
) -> JiraIssue:
    """Create a subtask under parent issue.

    Uses POST /rest/api/3/issue endpoint with parent link and "Sub-task" issue type.

    Args:
        parent_key: Parent issue key (e.g., "SCRUM-111")
        summary: Subtask summary/title
        description: Subtask description (optional)
        progress_callback: Optional retry visibility callback

    Returns:
        Created subtask JiraIssue

    Raises:
        JiraAPIError: On API errors (including if parent not found or subtasks not allowed)
    """
    # Extract project key from parent key
    project_key = parent_key.split("-")[0]

    logger.info(
        "Creating subtask",
        extra={
            "parent_key": parent_key,
            "project_key": project_key,
            "summary": summary,
            "jira_env": self.settings.jira_env,
        },
    )

    # Build payload
    payload: dict[str, Any] = {
        "fields": {
            "project": {"key": project_key},
            "parent": {"key": parent_key},
            "summary": summary,
            "issuetype": {"name": "Sub-task"},
        }
    }

    # Add description if provided
    if description:
        payload["fields"]["description"] = {
            "type": "doc",
            "version": 1,
            "content": [
                {
                    "type": "paragraph",
                    "content": [{"type": "text", "text": description}],
                }
            ],
        }

    # Dry-run mode
    if self.settings.jira_dry_run:
        self._mock_issue_counter += 1
        mock_key = f"{project_key}-DRY{self._mock_issue_counter}"
        logger.info(
            "Dry-run mode: would create subtask",
            extra={"mock_key": mock_key, "parent_key": parent_key, "summary": summary},
        )
        return JiraIssue(
            key=mock_key,
            summary=summary,
            status="Open",
            assignee=None,
            base_url=self.base_url,
        )

    response = await self._request(
        "POST",
        "/rest/api/3/issue",
        json_data=payload,
        progress_callback=progress_callback,
    )

    created_key = response.get("key", "")
    logger.info(
        "Subtask created successfully",
        extra={
            "subtask_key": created_key,
            "parent_key": parent_key,
        },
    )

    return await self.get_issue(created_key)
```
  </action>
  <verify>python -c "from src.jira.client import JiraService; print('create_subtask' in dir(JiraService))"</verify>
  <done>create_subtask method exists and creates Sub-task issue type</done>
</task>

<task type="auto">
  <name>Task 4: Replace handler stubs with real API calls</name>
  <files>src/slack/handlers.py</files>
  <action>
1. Add content extraction prompts at the top of the file (after DECISION_EXTRACTION_PROMPT):
```python
# Content extraction prompts for ticket operations (Phase 16)
UPDATE_EXTRACTION_PROMPT = '''Based on this conversation, extract what should be added to the Jira ticket description.

User request: {user_message}

Review context (if available):
{review_context}

Return the content to add to the ticket description.
Be concise and structured. Use Jira formatting:
- h3. for headers
- * for bullet points
- Keep it factual and actionable
'''

COMMENT_EXTRACTION_PROMPT = '''Extract a comment to add to the Jira ticket based on this request.

User request: {user_message}

Review context (if available):
{review_context}

Return a concise comment summarizing the key points. 1-3 sentences.
'''
```

2. Add helper functions before `_dispatch_result()`:
```python
async def _extract_update_content(
    result: dict,
    client: WebClient,
    channel_id: str,
    thread_ts: str,
) -> str:
    """Extract update content from conversation context using LLM."""
    from src.llm import get_llm

    # Get user message and review context
    user_message = result.get("user_message", "")
    review_context = result.get("review_context", {})
    review_summary = review_context.get("review_summary", "") if review_context else ""

    llm = get_llm()
    prompt = UPDATE_EXTRACTION_PROMPT.format(
        user_message=user_message,
        review_context=review_summary or "No review context available",
    )

    return await llm.chat(prompt)


async def _extract_comment_content(
    result: dict,
) -> str:
    """Extract comment content from conversation context using LLM."""
    from src.llm import get_llm

    user_message = result.get("user_message", "")
    review_context = result.get("review_context", {})
    review_summary = review_context.get("review_summary", "") if review_context else ""

    llm = get_llm()
    prompt = COMMENT_EXTRACTION_PROMPT.format(
        user_message=user_message,
        review_context=review_summary or "No review context available",
    )

    return await llm.chat(prompt)
```

3. Replace the stub handlers in `_dispatch_result()` (around lines 514-520):

Find this code:
```python
elif action_type in ("update", "add_comment"):
    # Stub response for future implementation
    client.chat_postMessage(
        channel=identity.channel_id,
        thread_ts=identity.thread_ts,
        text=f"I can help with {action_type.replace('_', ' ')} for *{ticket_key}*. (Full implementation coming soon)",
    )
```

Replace with:
```python
elif action_type == "update":
    # Update ticket with extracted content
    from src.jira.client import JiraService
    from src.config.settings import get_settings

    try:
        settings = get_settings()
        jira_service = JiraService(settings)

        # Extract update content
        update_content = await _extract_update_content(
            result, client, identity.channel_id, identity.thread_ts
        )

        # Update the ticket (append to description)
        await jira_service.update_issue(
            ticket_key,
            {"description": update_content},
        )
        await jira_service.close()

        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=f"Updated *{ticket_key}* with the latest context.",
        )
    except Exception as e:
        logger.error(f"Failed to update ticket: {e}", exc_info=True)
        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=f"Failed to update *{ticket_key}*: {str(e)}",
        )

elif action_type == "add_comment":
    # Add comment to ticket
    from src.jira.client import JiraService
    from src.config.settings import get_settings

    try:
        settings = get_settings()
        jira_service = JiraService(settings)

        # Extract comment content
        comment_content = await _extract_comment_content(result)

        # Add comment to the ticket
        await jira_service.add_comment(ticket_key, comment_content)
        await jira_service.close()

        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=f"Added comment to *{ticket_key}*.",
        )
    except Exception as e:
        logger.error(f"Failed to add comment: {e}", exc_info=True)
        client.chat_postMessage(
            channel=identity.channel_id,
            thread_ts=identity.thread_ts,
            text=f"Failed to add comment to *{ticket_key}*: {str(e)}",
        )
```

4. Update the ticket_action_node to include user_message in result (needed for content extraction):
This is already handled by intent_result which has the message. Add to ticket_action_node output.
  </action>
  <verify>grep -n "add_comment\|update_issue" src/slack/handlers.py | head -10</verify>
  <done>Handler dispatches update and add_comment with real API calls, no more stubs</done>
</task>

<task type="auto">
  <name>Task 5: Pass user_message through ticket_action flow</name>
  <files>src/graph/nodes/ticket_action.py</files>
  <action>
Update ticket_action_node to include latest user message in the result:

1. Import HumanMessage at the top:
```python
from langchain_core.messages import HumanMessage
```

2. In ticket_action_node, after getting intent_result, extract user message:
```python
# Get latest human message for content extraction
messages = state.get("messages", [])
latest_human_message = ""
for msg in reversed(messages):
    if isinstance(msg, HumanMessage):
        latest_human_message = msg.content
        break
```

3. Include in the returned decision_result:
```python
return {
    "decision_result": {
        "action": "ticket_action",
        "ticket_key": ticket_key,
        "action_type": action_type,
        "already_bound_to_same": already_bound_to_same,
        "user_message": latest_human_message,  # For content extraction
        "review_context": state.get("review_context"),  # Include if available
    }
}
```
  </action>
  <verify>grep -n "user_message\|review_context" src/graph/nodes/ticket_action.py</verify>
  <done>ticket_action_node passes user_message and review_context for content extraction</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.jira.client import JiraService; print('update_issue' in dir(JiraService))"` returns True
- [ ] `python -c "from src.jira.client import JiraService; print('add_comment' in dir(JiraService))"` returns True
- [ ] `python -c "from src.jira.client import JiraService; print('create_subtask' in dir(JiraService))"` returns True
- [ ] `grep -r "update_issue\|add_comment" src/slack/handlers.py` shows real API calls (not stubs)
- [ ] No Python syntax errors or import issues
</verification>

<success_criteria>
- Three new JiraService methods: update_issue, add_comment, create_subtask
- All methods handle dry-run mode and ADF conversion
- Handler dispatch replaces stubs with real API calls
- Content extraction uses LLM prompts
- user_message passed through ticket_action flow
- Error handling with user-friendly messages
</success_criteria>

<output>
After completion, create `.planning/phases/16-ticket-operations/16-01-SUMMARY.md`
</output>
