---
phase: 20-brain-refactor
plan: 07
type: execute
wave: 4
depends_on: ["20-04", "20-05", "20-06"]
files_modified:
  - src/schemas/state.py
  - src/graph/nodes/review.py
  - src/graph/nodes/review_continuation.py
autonomous: true
---

<objective>
Implement ReviewArtifact with freeze semantics: frozen review remains available for handoff but doesn't trigger continuation.

Purpose: Fix sticky continuation bug. Frozen context doesn't bias next message's intent.
Output: ReviewArtifact TypedDict, freeze_review() function, updated review nodes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-brain-refactor/20-CONTEXT.md
@src/schemas/state.py
@src/graph/nodes/review.py
@src/graph/nodes/review_continuation.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add ReviewArtifact TypedDict</name>
  <files>src/schemas/state.py</files>
  <action>
Add ReviewArtifact TypedDict to state.py:

```python
class ReviewArtifact(TypedDict):
    """Frozen review context for handoff.

    Explicit structure instead of raw review_context dict.
    Used for Review→Ticket handoff after freeze.
    """
    summary: str  # Compressed review content
    kind: Literal["architecture", "security", "pm"]  # Which persona gave review
    version: int  # For patch mode tracking
    topic: str  # What was reviewed
    frozen_at: str  # ISO timestamp when frozen
    thread_ts: str  # Source thread for reference
```

Add to AgentState:
```python
    # Review artifact (Phase 20 - frozen handoff)
    review_artifact: Optional[ReviewArtifact]  # Frozen review for handoff (not continuation!)
```

Key semantics:
- review_context (existing) = active review, triggers continuation
- review_artifact (new) = frozen review, available for handoff but no continuation
  </action>
  <verify>python -c "from src.schemas.state import ReviewArtifact; print(ReviewArtifact.__annotations__)"</verify>
  <done>ReviewArtifact TypedDict exists with summary, kind, version, topic, frozen_at, thread_ts</done>
</task>

<task type="auto">
  <name>Task 2: Implement freeze_review function</name>
  <files>src/graph/nodes/review.py</files>
  <action>
Add freeze_review function that moves review_context to review_artifact:

```python
def freeze_review(state: dict) -> dict:
    """Freeze current review context into artifact.

    Called when REVIEW_COMPLETE detected (thanks/ok/got it).
    Moves review_context -> review_artifact and clears review_context.

    Freeze semantics (from 20-CONTEXT.md):
    - review_artifact remains accessible for Review→Ticket handoff
    - But doesn't trigger continuation automatically
    - And doesn't bias next message's intent classification

    Returns:
        State update with review_artifact set and review_context cleared
    """
    review_context = state.get("review_context")
    if not review_context:
        return {}

    from datetime import datetime

    artifact: ReviewArtifact = {
        "summary": review_context.get("review_summary", ""),
        "kind": review_context.get("persona", "architect"),
        "version": 1,  # First freeze is v1
        "topic": review_context.get("topic", ""),
        "frozen_at": datetime.utcnow().isoformat(),
        "thread_ts": review_context.get("thread_ts", ""),
    }

    return {
        "review_artifact": artifact,
        "review_context": None,  # Clear to stop continuation triggers
    }
```

Also add REVIEW_COMPLETE patterns for detecting freeze trigger:
```python
REVIEW_COMPLETE_PATTERNS = [
    r"\bthanks?\b",
    r"\bok\b",
    r"\bgot it\b",
    r"\ball good\b",
    r"\blooks?\s+good\b",
    r"\bperfect\b",
    r"\bgreat\b",
]
```
  </action>
  <verify>python -c "from src.graph.nodes.review import freeze_review; print('OK')"</verify>
  <done>freeze_review function moves review_context to review_artifact</done>
</task>

<task type="auto">
  <name>Task 3: Update review_continuation to check frozen state</name>
  <files>src/graph/nodes/review_continuation.py</files>
  <action>
Update review_continuation_node to:

1. Check if review_context exists (not frozen)
2. If review_context.state == "POSTED" or review_context is None, don't continue

Add at the start of review_continuation_node:
```python
    # Don't continue if review is frozen or already posted
    review_context = state.get("review_context")
    if not review_context:
        logger.info("No review context - cannot continue (may be frozen)")
        return {"decision_result": {"action": "error", "message": "No active review to continue"}}

    review_state = review_context.get("state")
    if review_state in ("POSTED", "APPROVED"):
        logger.info(f"Review already {review_state} - not continuing")
        return {"decision_result": {"action": "error", "message": "Review already completed"}}
```

This prevents continuation on frozen/completed reviews.
  </action>
  <verify>python -c "from src.graph.nodes.review_continuation import review_continuation_node; print('OK')"</verify>
  <done>review_continuation_node respects freeze semantics</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] ReviewArtifact TypedDict has all required fields
- [ ] freeze_review moves context to artifact and clears context
- [ ] review_continuation respects frozen state
- [ ] `python -m pytest tests/ -x --tb=short` passes
</verification>

<success_criteria>
- ReviewArtifact has explicit structure (summary, kind, version, etc.)
- freeze_review correctly transitions from context to artifact
- Frozen reviews don't trigger continuation
- Frozen reviews remain available for handoff
</success_criteria>

<output>
After completion, create `.planning/phases/20-brain-refactor/20-07-SUMMARY.md`
</output>
