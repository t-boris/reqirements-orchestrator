---
phase: 20-brain-refactor
plan: 08
type: execute
wave: 4
depends_on: ["20-04", "20-05", "20-06"]
files_modified:
  - src/graph/nodes/review.py
  - src/slack/blocks/review.py
autonomous: true
---

<objective>
Implement patch mode for reviews: only output changes + updated questions, not full regeneration.

Purpose: Reduce expensive full regeneration on every answer. Patch mode is default.
Output: Patch structure (4 sections, max 12 bullets), "Show full architecture" button.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-brain-refactor/20-CONTEXT.md
@src/graph/nodes/review.py
@src/graph/nodes/review_continuation.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create patch generation prompt</name>
  <files>src/graph/nodes/review_continuation.py</files>
  <action>
Add patch mode prompt that generates only changes, not full review:

```python
PATCH_REVIEW_PROMPT = '''Based on the user's answers, generate a PATCH update to the architecture review.

Previous review (version {version}):
{previous_summary}

User's answers:
{user_answers}

Generate a PATCH with exactly these 4 sections (max 12 bullets total):

## New Decisions
[Decisions made based on user's answers - max 3 bullets]

## New Risks
[New risks identified based on answers - max 3 bullets, or "None identified"]

## New Open Questions
[Any new questions that arose - max 3 bullets, or "None"]

## Changes Since v{version}
[What changed from previous version - max 3 bullets]

Keep it concise. This is a PATCH, not a full review.
If user wants full synthesis, they can click "Show full architecture".
'''
```

Update review_continuation_node to use patch mode by default:
```python
async def review_continuation_node(state: dict) -> dict:
    """Continue review conversation with patch mode."""
    ...
    # Use patch mode by default
    version = (state.get("review_artifact", {}).get("version", 0) or
               state.get("review_context", {}).get("version", 0)) + 1

    prompt = PATCH_REVIEW_PROMPT.format(
        version=version - 1,
        previous_summary=previous_summary,
        user_answers=user_message,
    )
    ...
```
  </action>
  <verify>python -c "from src.graph.nodes.review_continuation import PATCH_REVIEW_PROMPT; print('OK')"</verify>
  <done>Patch mode prompt added with 4-section structure</done>
</task>

<task type="auto">
  <name>Task 2: Add full synthesis function</name>
  <files>src/graph/nodes/review.py</files>
  <action>
Add function for full synthesis (triggered by "Show full architecture" button):

```python
FULL_SYNTHESIS_PROMPT = '''Generate a complete architecture synthesis incorporating all previous patches.

Original topic: {topic}
Persona: {persona}

Previous review versions:
{all_patches}

Current state of open questions:
{open_questions}

Generate a COMPLETE architecture document that:
1. Incorporates all decisions from all versions
2. Reflects current risks and mitigations
3. Lists any remaining open questions
4. Provides clear recommendations

This is the full synthesis - be comprehensive but structured.
'''


async def generate_full_synthesis(state: dict) -> dict:
    """Generate full architecture synthesis from all patches.

    Triggered by "Show full architecture" button.
    Combines all patch history into complete document.
    """
    from src.llm import get_llm

    review_context = state.get("review_context", {})
    review_artifact = state.get("review_artifact", {})

    # Gather all patches/versions
    patches = []
    if review_artifact:
        patches.append(f"v{review_artifact.get('version', 1)}: {review_artifact.get('summary', '')}")
    if review_context:
        patches.append(f"Current: {review_context.get('review_summary', '')}")

    topic = review_context.get("topic") or review_artifact.get("topic", "architecture")
    persona = review_context.get("persona") or review_artifact.get("kind", "architect")

    llm = get_llm()
    prompt = FULL_SYNTHESIS_PROMPT.format(
        topic=topic,
        persona=persona,
        all_patches="\n\n".join(patches) if patches else "No previous patches",
        open_questions="See previous patches for open questions",
    )

    full_review = await llm.chat(prompt)

    return {
        "decision_result": {
            "action": "full_synthesis",
            "review": full_review,
            "topic": topic,
            "persona": persona,
        },
    }
```
  </action>
  <verify>python -c "from src.graph.nodes.review import generate_full_synthesis; print('OK')"</verify>
  <done>Full synthesis function added for "Show full architecture"</done>
</task>

<task type="auto">
  <name>Task 3: Add "Show full architecture" button</name>
  <files>src/slack/blocks/review.py</files>
  <action>
Create or update `src/slack/blocks/review.py` with patch mode UI:

```python
"""Review-related blocks including patch mode UI."""


def build_patch_review_blocks(
    patch_content: str,
    version: int,
    topic: str,
) -> list[dict]:
    """Build blocks for patch review output.

    Shows patch with "Show full architecture" button.
    """
    return [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"Architecture Update (v{version})",
            },
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": patch_content,
            },
        },
        {
            "type": "divider",
        },
        {
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Show Full Architecture"},
                    "action_id": "review_show_full",
                    "value": f"topic:{topic}",
                },
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Approve & Post Decision"},
                    "action_id": "review_approve_decision",
                    "style": "primary",
                },
            ],
        },
    ]


def build_full_synthesis_blocks(
    full_content: str,
    topic: str,
    persona: str,
) -> list[dict]:
    """Build blocks for full synthesis output."""
    return [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"Complete Architecture Review",
            },
        },
        {
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": f"*{persona.title()} Review* | Topic: {topic}",
                },
            ],
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": full_content,
            },
        },
        {
            "type": "divider",
        },
        {
            "type": "actions",
            "elements": [
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Approve & Post Decision"},
                    "action_id": "review_approve_decision",
                    "style": "primary",
                },
                {
                    "type": "button",
                    "text": {"type": "plain_text", "text": "Turn into Ticket"},
                    "action_id": "review_to_ticket",
                },
            ],
        },
    ]
```
  </action>
  <verify>python -c "from src.slack.blocks.review import build_patch_review_blocks; print('OK')"</verify>
  <done>Patch and full synthesis blocks with buttons</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] Patch mode prompt generates 4 sections, max 12 bullets
- [ ] Full synthesis combines all patches into complete document
- [ ] "Show full architecture" button works
- [ ] `python -m pytest tests/ -x --tb=short` passes
</verification>

<success_criteria>
- Patch mode is default for review continuation (not full regeneration)
- Patch structure: New Decisions, New Risks, New Open Questions, Changes
- "Show full architecture" triggers complete synthesis
- Version tracking works across patches
</success_criteria>

<output>
After completion, create `.planning/phases/20-brain-refactor/20-08-SUMMARY.md`
</output>
