---
phase: 20-brain-refactor
plan: 10
type: execute
wave: 5
depends_on: ["20-07", "20-08"]
files_modified:
  - src/graph/nodes/multi_ticket.py
  - src/slack/handlers/multi_ticket.py
  - src/jira/client.py
autonomous: true
---

<objective>
Implement multi-ticket creation: dry-run validation, batch creation, Epic linking.

Purpose: Complete multi-ticket flow with Jira integration.
Output: Jira batch creation, dry-run validation, story-to-epic linking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-brain-refactor/20-CONTEXT.md
@.planning/phases/20-brain-refactor/20-09-SUMMARY.md
@src/jira/client.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add dry-run validation to JiraService</name>
  <files>src/jira/client.py</files>
  <action>
Add dry-run validation method to JiraService that checks:
- All required fields present
- Field mappings valid
- User has create permission

```python
async def validate_issue_dry_run(
    self,
    project_key: str,
    issue_type: str,
    fields: dict,
) -> dict:
    """Validate issue creation without actually creating.

    Checks:
    - Project exists and user has access
    - Issue type valid for project
    - Required fields present
    - Field values valid

    Returns:
        {"valid": True} or {"valid": False, "errors": [...]}
    """
    errors = []

    # Check project access
    project = await self._get_project(project_key)
    if not project:
        errors.append(f"Project {project_key} not found or no access")
        return {"valid": False, "errors": errors}

    # Check issue type valid
    valid_types = await self._get_issue_types(project_key)
    if issue_type not in [t["name"] for t in valid_types]:
        errors.append(f"Issue type '{issue_type}' not valid for project {project_key}")

    # Check required fields
    required = await self._get_required_fields(project_key, issue_type)
    for field in required:
        if field not in fields or not fields[field]:
            errors.append(f"Required field '{field}' is missing")

    if errors:
        return {"valid": False, "errors": errors}

    return {"valid": True}
```

This implements the dry-run validation guardrail from 20-CONTEXT.md v4.
  </action>
  <verify>python -c "from src.jira.client import JiraService; print(hasattr(JiraService, 'validate_issue_dry_run'))"</verify>
  <done>JiraService has validate_issue_dry_run method</done>
</task>

<task type="auto">
  <name>Task 2: Add batch creation with Epic linking</name>
  <files>src/graph/nodes/multi_ticket.py</files>
  <action>
Add batch creation function that:
1. Validates all items with dry-run
2. Creates Epic first
3. Creates stories linked to Epic (not subtasks)
4. Returns all created keys

```python
async def create_multi_ticket_batch(state: dict) -> dict:
    """Create all items in Jira with Epic linking.

    Flow:
    1. Dry-run validate all items
    2. Create Epic first
    3. Create stories linked to Epic (parent_link, not subtask)
    4. Return created keys

    From 20-CONTEXT.md: Stories are linked to Epic, not subtasks (configurable).
    """
    from src.jira import get_jira_service

    multi_state = state.get("multi_ticket_state")
    if not multi_state:
        return {"decision_result": {"action": "error", "message": "No multi-ticket state"}}

    items = multi_state["items"]
    jira = get_jira_service()
    project_key = state.get("channel_context", {}).get("project_key", "PROJ")

    # Step 1: Dry-run validate all items
    for item in items:
        issue_type = "Epic" if item["type"] == "epic" else "Story"
        fields = {
            "summary": item["title"],
            "description": item["description"],
        }

        validation = await jira.validate_issue_dry_run(project_key, issue_type, fields)
        if not validation.get("valid"):
            errors = validation.get("errors", [])
            return {
                "decision_result": {
                    "action": "validation_error",
                    "item_id": item["id"],
                    "errors": errors,
                },
            }

    # Step 2: Create Epic first
    created_keys = []
    epic_key = None

    for item in items:
        if item["type"] == "epic":
            epic_result = await jira.create_issue(
                project_key=project_key,
                issue_type="Epic",
                summary=item["title"],
                description=item["description"],
            )
            epic_key = epic_result.get("key")
            created_keys.append(epic_key)
            break

    # Step 3: Create stories linked to Epic
    for item in items:
        if item["type"] == "story":
            # Link to Epic using parent field (not subtask)
            story_result = await jira.create_issue(
                project_key=project_key,
                issue_type="Story",
                summary=item["title"],
                description=item["description"],
                parent_key=epic_key,  # Epic link
            )
            created_keys.append(story_result.get("key"))

    # Update state with created keys
    multi_state["created_keys"] = created_keys

    return {
        "multi_ticket_state": multi_state,
        "pending_action": None,
        "workflow_step": None,
        "decision_result": {
            "action": "multi_ticket_created",
            "keys": created_keys,
            "epic_key": epic_key,
        },
    }
```
  </action>
  <verify>python -c "from src.graph.nodes.multi_ticket import create_multi_ticket_batch; print('OK')"</verify>
  <done>Batch creation with dry-run and Epic linking</done>
</task>

<task type="auto">
  <name>Task 3: Create multi-ticket handlers</name>
  <files>src/slack/handlers/multi_ticket.py</files>
  <action>
Create handlers for multi-ticket actions:

```python
"""Handlers for multi-ticket workflow."""
import logging

from slack_sdk.web import WebClient

logger = logging.getLogger(__name__)


def handle_multi_ticket_confirm_quantity(body: dict, client: WebClient):
    """Handle quantity confirmation (>3 items)."""
    channel = body.get("channel", {}).get("id")
    message_ts = body.get("message", {}).get("ts")

    # Update state to confirmed
    # Continue to preview
    client.chat_update(
        channel=channel,
        ts=message_ts,
        text="Quantity confirmed. Preparing preview...",
        blocks=[],
    )

    # State update + preview will be triggered by graph runner


def handle_multi_ticket_split(body: dict, client: WebClient):
    """Handle split into batches request."""
    channel = body.get("channel", {}).get("id")
    message_ts = body.get("message", {}).get("ts")

    client.chat_update(
        channel=channel,
        ts=message_ts,
        text="Splitting into batches. I'll create the Epic first, then add stories in groups.",
        blocks=[],
    )

    # TODO: Implement batch splitting logic


def handle_multi_ticket_edit_story(body: dict, client: WebClient):
    """Handle edit story button click.

    Opens modal to edit story title/description.
    """
    from src.slack.modals import open_story_edit_modal

    story_id = _extract_story_id(body)
    trigger_id = body.get("trigger_id")

    # Open edit modal
    open_story_edit_modal(client, trigger_id, story_id)


def handle_multi_ticket_approve(body: dict, client: WebClient):
    """Handle approve all button click.

    Triggers batch creation in Jira.
    """
    channel = body.get("channel", {}).get("id")
    message_ts = body.get("message", {}).get("ts")

    # Check ui_version from action value
    ui_version = _extract_ui_version(body)

    client.chat_update(
        channel=channel,
        ts=message_ts,
        text="Creating tickets in Jira...",
        blocks=[],
    )

    # Trigger batch creation via graph runner


def handle_multi_ticket_cancel(body: dict, client: WebClient):
    """Handle cancel button click."""
    channel = body.get("channel", {}).get("id")
    message_ts = body.get("message", {}).get("ts")

    client.chat_update(
        channel=channel,
        ts=message_ts,
        text="Multi-ticket creation cancelled.",
        blocks=[],
    )


def _extract_story_id(body: dict) -> str:
    """Extract story ID from action_id."""
    actions = body.get("actions", [])
    if actions:
        action_id = actions[0].get("action_id", "")
        # Format: multi_ticket_edit_story:story_id:ui_version
        parts = action_id.split(":")
        if len(parts) >= 2:
            return parts[1]
    return ""


def _extract_ui_version(body: dict) -> int:
    """Extract ui_version from action value."""
    actions = body.get("actions", [])
    if actions:
        action_id = actions[0].get("action_id", "")
        parts = action_id.split(":")
        if len(parts) >= 2 and parts[-1].isdigit():
            return int(parts[-1])
    return 0
```
  </action>
  <verify>python -c "from src.slack.handlers.multi_ticket import handle_multi_ticket_approve; print('OK')"</verify>
  <done>Multi-ticket handlers for confirm, edit, approve, cancel</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] JiraService.validate_issue_dry_run checks all required fields
- [ ] Batch creation creates Epic first, then stories linked to Epic
- [ ] Handlers work for confirm, edit, approve, cancel
- [ ] `python -m pytest tests/ -x --tb=short` passes
</verification>

<success_criteria>
- Dry-run validation catches errors before creation
- Epic created first, stories linked with parent (not subtask)
- Handlers update Slack UI appropriately
- Created keys returned for confirmation
</success_criteria>

<output>
After completion, create `.planning/phases/20-brain-refactor/20-10-SUMMARY.md`
</output>
