---
phase: 20-brain-refactor
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/event_validation.py
autonomous: true
---

<objective>
Create event validation logic: allowed events per workflow step, stale UI detection.

Purpose: Prevents stale button clicks from affecting current state. Each WorkflowStep defines allowed events.
Output: ALLOWED_EVENTS mapping, validate_event function, UI versioning helpers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-brain-refactor/20-CONTEXT.md
@src/schemas/state.py
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create event validation module</name>
  <files>src/graph/event_validation.py</files>
  <action>
Create new file `src/graph/event_validation.py`:

```python
"""Event validation for workflow steps.

Each WorkflowStep has a set of allowed event actions.
Invalid events return "stale UI" message instead of processing.
"""
import logging
from typing import Optional

from src.schemas.state import WorkflowStep

logger = logging.getLogger(__name__)


# Allowed event actions per workflow step
# Empty set = no workflow actions allowed
ALLOWED_EVENTS: dict[WorkflowStep, set[str]] = {
    WorkflowStep.DRAFT_PREVIEW: {"approve", "reject", "edit"},
    WorkflowStep.MULTI_TICKET_PREVIEW: {"approve", "edit_story", "cancel", "confirm_quantity"},
    WorkflowStep.DECISION_PREVIEW: {"approve", "edit", "cancel"},
    WorkflowStep.REVIEW_ACTIVE: {"show_full", "approve_decision", "turn_into_ticket"},
    WorkflowStep.REVIEW_FROZEN: set(),  # No workflow actions on frozen review
    WorkflowStep.SCOPE_GATE: {"select_review", "select_ticket", "dismiss", "remember"},
}


def validate_event(
    step: Optional[WorkflowStep],
    event_action: str,
) -> bool:
    """Check if event action is allowed for current workflow step.

    Args:
        step: Current workflow step (None if no active workflow)
        event_action: The action being attempted (e.g., "approve", "edit")

    Returns:
        True if event is allowed, False for stale/invalid events
    """
    if step is None:
        # No active workflow - all events invalid
        logger.warning(f"Event '{event_action}' received with no active workflow step")
        return False

    if step not in ALLOWED_EVENTS:
        # Unknown step - defensive
        logger.warning(f"Unknown workflow step: {step}")
        return False

    allowed = event_action in ALLOWED_EVENTS[step]
    if not allowed:
        logger.info(
            f"Stale event detected: '{event_action}' not allowed in step {step.value}. "
            f"Allowed: {ALLOWED_EVENTS[step]}"
        )

    return allowed


def validate_ui_version(
    state_ui_version: int,
    event_ui_version: int,
) -> bool:
    """Check if button click matches current UI version.

    Prevents stale preview button clicks after edit created new version.

    Args:
        state_ui_version: Current ui_version in state
        event_ui_version: ui_version from button click value

    Returns:
        True if versions match, False if stale
    """
    if event_ui_version != state_ui_version:
        logger.info(
            f"Stale UI version: button has v{event_ui_version}, state has v{state_ui_version}"
        )
        return False
    return True


# Stale UI response messages
STALE_EVENT_MESSAGE = "This action is no longer available. The workflow has moved on."
STALE_VERSION_MESSAGE = "This preview is outdated. Please use the current version."
ALREADY_PROCESSED_MESSAGE = "This action was already processed."
```

Key design decisions:
- WorkflowStep -> set[str] mapping for allowed events
- Separate ui_version check for same-step stale detection
- Clear logging for debugging
- Pre-defined error messages
  </action>
  <verify>python -c "from src.graph.event_validation import validate_event, validate_ui_version, ALLOWED_EVENTS; print('OK')"</verify>
  <done>Event validation module created with validate_event, validate_ui_version, ALLOWED_EVENTS</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for event validation</name>
  <files>tests/test_event_validation.py</files>
  <action>
Create test file for event validation:

```python
"""Tests for event validation logic."""
import pytest
from src.schemas.state import WorkflowStep
from src.graph.event_validation import (
    validate_event,
    validate_ui_version,
    ALLOWED_EVENTS,
)


class TestValidateEvent:
    """Tests for validate_event function."""

    def test_approve_allowed_in_draft_preview(self):
        """Approve button works in draft preview."""
        assert validate_event(WorkflowStep.DRAFT_PREVIEW, "approve") is True

    def test_edit_allowed_in_draft_preview(self):
        """Edit button works in draft preview."""
        assert validate_event(WorkflowStep.DRAFT_PREVIEW, "edit") is True

    def test_approve_not_allowed_in_scope_gate(self):
        """Approve button not allowed in scope gate (stale)."""
        assert validate_event(WorkflowStep.SCOPE_GATE, "approve") is False

    def test_no_events_allowed_in_frozen_review(self):
        """Frozen review has no allowed actions."""
        assert validate_event(WorkflowStep.REVIEW_FROZEN, "approve") is False
        assert validate_event(WorkflowStep.REVIEW_FROZEN, "edit") is False

    def test_none_step_rejects_all(self):
        """No workflow step = all events rejected."""
        assert validate_event(None, "approve") is False

    def test_scope_gate_actions(self):
        """Scope gate allows its specific actions."""
        assert validate_event(WorkflowStep.SCOPE_GATE, "select_review") is True
        assert validate_event(WorkflowStep.SCOPE_GATE, "select_ticket") is True
        assert validate_event(WorkflowStep.SCOPE_GATE, "dismiss") is True


class TestValidateUiVersion:
    """Tests for UI version validation."""

    def test_matching_version_passes(self):
        """Same version = valid."""
        assert validate_ui_version(5, 5) is True

    def test_old_version_fails(self):
        """Old button version = stale."""
        assert validate_ui_version(6, 5) is False

    def test_future_version_fails(self):
        """Future version (shouldn't happen) = also stale."""
        assert validate_ui_version(5, 6) is False


class TestAllowedEventsComplete:
    """Verify ALLOWED_EVENTS covers all WorkflowStep values."""

    def test_all_steps_have_allowed_events(self):
        """Every WorkflowStep must be in ALLOWED_EVENTS."""
        for step in WorkflowStep:
            assert step in ALLOWED_EVENTS, f"Missing ALLOWED_EVENTS for {step}"
```
  </action>
  <verify>python -m pytest tests/test_event_validation.py -v</verify>
  <done>Event validation tests pass</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.graph.event_validation import validate_event, ALLOWED_EVENTS"` succeeds
- [ ] All WorkflowStep values have entries in ALLOWED_EVENTS
- [ ] `python -m pytest tests/test_event_validation.py -v` passes
- [ ] `python -m pytest tests/ -x --tb=short` passes (no regressions)
</verification>

<success_criteria>
- ALLOWED_EVENTS mapping covers all WorkflowStep values
- validate_event function returns True/False correctly
- validate_ui_version prevents stale preview clicks
- Unit tests cover key scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/20-brain-refactor/20-03-SUMMARY.md`
</output>
