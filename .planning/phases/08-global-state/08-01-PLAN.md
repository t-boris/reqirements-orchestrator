---
phase: 08-global-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/db/models.py, src/db/channel_context_store.py, src/db/__init__.py, src/config/settings.py]
autonomous: true
---

<objective>
Build ChannelContext schema, ChannelContextStore, and config settings for Phase 8 foundation.

Purpose: Foundation layer for all channel state - schema, storage, and configuration. Other plans depend on this.
Output: `ChannelContextStore` class with CRUD operations, updated `ChannelContext` model, config settings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-global-state/08-CONTEXT.md

@src/db/models.py
@src/db/session_store.py
@src/db/approval_store.py
@src/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand ChannelContext model with layered structure</name>
  <files>src/db/models.py</files>
  <action>
Replace the placeholder `ChannelContext` model with full layered structure:

```python
class ChannelConfig(BaseModel):
    """Layer 1: Manual channel configuration (highest priority for defaults)."""
    default_jira_project: Optional[str] = None
    secondary_projects: list[str] = Field(default_factory=list)
    trigger_rule: Literal["mention_only", "listen_all"] = "mention_only"
    epic_binding_behavior: Literal["suggest", "require", "skip"] = "suggest"
    config_permissions: Literal["locked", "open"] = "open"

class ChannelKnowledge(BaseModel):
    """Layer 2: Extracted from pinned content (highest priority for facts)."""
    naming_convention: Optional[str] = None
    definition_of_done: Optional[str] = None
    api_format_rules: Optional[str] = None
    custom_rules: dict[str, str] = Field(default_factory=dict)
    source_pin_ids: list[str] = Field(default_factory=list)

class ChannelActivitySnapshot(BaseModel):
    """Layer 3: Live summary of channel activity."""
    active_epics: list[str] = Field(default_factory=list)
    recent_tickets: list[str] = Field(default_factory=list)  # Last 10 ticket keys
    top_constraints: list[dict] = Field(default_factory=list)
    unresolved_conflicts: list[dict] = Field(default_factory=list)
    last_updated: Optional[datetime] = None

class ChannelContext(BaseModel):
    """Full channel context with 4 layers."""
    id: str = Field(description="UUID for the context record")
    team_id: str = Field(description="Slack team/workspace ID")
    channel_id: str = Field(description="Slack channel ID (unique)")

    # 4 layers with priority order: knowledge > jira > config > derived
    config: ChannelConfig = Field(default_factory=ChannelConfig)
    knowledge: ChannelKnowledge = Field(default_factory=ChannelKnowledge)
    activity: ChannelActivitySnapshot = Field(default_factory=ChannelActivitySnapshot)
    derived_signals: dict = Field(default_factory=dict)  # Layer 4: TTL-based

    # Version tracking
    version: int = Field(default=1)
    pinned_digest: Optional[str] = None  # Hash of pinned content
    jira_sync_cursor: Optional[str] = None

    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
```

Keep existing imports, add `from datetime import datetime, timezone` if not present.
  </action>
  <verify>python -c "from src.db.models import ChannelContext, ChannelConfig, ChannelKnowledge; print('ok')"</verify>
  <done>ChannelContext model has 4 layers: config, knowledge, activity, derived_signals</done>
</task>

<task type="auto">
  <name>Task 2: Create ChannelContextStore with CRUD operations</name>
  <files>src/db/channel_context_store.py</files>
  <action>
Create `ChannelContextStore` following the `SessionStore` pattern (raw SQL, Pydantic DTOs):

```python
class ChannelContextStore:
    """Async CRUD for channel context using raw SQL.

    Usage:
        async with get_connection() as conn:
            store = ChannelContextStore(conn)
            ctx = await store.get_or_create(team_id, channel_id)
    """

    def __init__(self, conn: AsyncConnection) -> None:
        self._conn = conn

    async def create_tables(self) -> None:
        """Create channel_context table with migration for existing."""
        # CREATE TABLE IF NOT EXISTS channel_context (
        #   id UUID PRIMARY KEY,
        #   team_id TEXT NOT NULL,
        #   channel_id TEXT NOT NULL,
        #   config_json JSONB DEFAULT '{}',
        #   knowledge_json JSONB DEFAULT '{}',
        #   activity_json JSONB DEFAULT '{}',
        #   derived_json JSONB DEFAULT '{}',
        #   version INT DEFAULT 1,
        #   pinned_digest TEXT,
        #   jira_sync_cursor TEXT,
        #   created_at TIMESTAMPTZ DEFAULT NOW(),
        #   updated_at TIMESTAMPTZ DEFAULT NOW(),
        #   UNIQUE(team_id, channel_id)
        # )

    async def get_or_create(self, team_id: str, channel_id: str) -> ChannelContext:
        """Get existing context or create empty one."""

    async def get_by_channel(self, team_id: str, channel_id: str) -> Optional[ChannelContext]:
        """Get context if exists."""

    async def update_config(self, team_id: str, channel_id: str, config: ChannelConfig) -> ChannelContext:
        """Update Layer 1 config."""

    async def update_knowledge(self, team_id: str, channel_id: str, knowledge: ChannelKnowledge, pinned_digest: str) -> ChannelContext:
        """Update Layer 2 knowledge with new pinned_digest."""

    async def update_activity(self, team_id: str, channel_id: str, activity: ChannelActivitySnapshot) -> ChannelContext:
        """Update Layer 3 activity snapshot."""

    async def update_derived(self, team_id: str, channel_id: str, derived: dict) -> ChannelContext:
        """Update Layer 4 derived signals."""

    async def bump_version(self, team_id: str, channel_id: str) -> int:
        """Increment version and return new value."""

    async def list_channels(self, team_id: str) -> list[ChannelContext]:
        """List all channels with context for a team."""
```

Follow SessionStore patterns:
- Raw SQL with parameterized queries
- Return Pydantic models
- Use `json.dumps()` / `json.loads()` for JSONB columns
- Commit after each write operation
  </action>
  <verify>python -c "from src.db.channel_context_store import ChannelContextStore; print('ok')"</verify>
  <done>ChannelContextStore class with all CRUD methods</done>
</task>

<task type="auto">
  <name>Task 3: Add config settings and update db exports</name>
  <files>src/config/settings.py, src/db/__init__.py</files>
  <action>
1. Add to Settings class in settings.py:

```python
# Channel Context settings (Phase 8)
channel_context_activity_refresh_hours: int = 6  # How often to refresh activity snapshot
channel_context_derived_ttl_days: int = 14  # TTL for derived signals
channel_context_root_window_days: int = 60  # How far back to index root messages
channel_context_max_bullets: int = 15  # Max bullets in compact context
```

2. Update src/db/__init__.py exports:

```python
from src.db.channel_context_store import ChannelContextStore
from src.db.models import ChannelContext, ChannelConfig, ChannelKnowledge, ChannelActivitySnapshot
```
  </action>
  <verify>python -c "from src.db import ChannelContextStore, ChannelContext, ChannelConfig; print('ok')"</verify>
  <done>Settings added, exports updated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.db.models import ChannelContext, ChannelConfig, ChannelKnowledge, ChannelActivitySnapshot"` succeeds
- [ ] `python -c "from src.db.channel_context_store import ChannelContextStore"` succeeds
- [ ] `python -c "from src.db import ChannelContextStore, ChannelContext"` succeeds
- [ ] Settings include channel_context_* fields
- [ ] ChannelContext has version, pinned_digest, jira_sync_cursor fields
</verification>

<success_criteria>

- ChannelContext model with 4 layers (config, knowledge, activity, derived)
- ChannelContextStore with all CRUD operations
- Version and digest tracking for idempotency
- Settings for refresh intervals and TTLs
- All exports properly configured
</success_criteria>

<output>
After completion, create `.planning/phases/08-global-state/08-01-SUMMARY.md`
</output>
