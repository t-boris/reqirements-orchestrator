---
phase: 08-global-state
plan: 05
type: execute
wave: 3
depends_on: ["08-02", "08-03", "08-04"]
files_modified: [src/context/retriever.py, src/context/__init__.py, src/schemas/state.py, src/graph/nodes/intake.py]
autonomous: true
---

<objective>
Build context retrieval API and inject channel context into AgentState on new thread.

Purpose: Final piece - how agent gets compressed channel context. Compact mode (10-20 bullets) for production.
Output: `ChannelContextRetriever` class, AgentState with channel_context field, injection in intake node.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-global-state/08-CONTEXT.md
@.planning/phases/08-global-state/08-01-SUMMARY.md
@.planning/phases/08-global-state/08-02-SUMMARY.md
@.planning/phases/08-global-state/08-03-SUMMARY.md
@.planning/phases/08-global-state/08-04-SUMMARY.md

@src/db/channel_context_store.py
@src/context/pin_extractor.py
@src/context/root_indexer.py
@src/schemas/state.py
@src/graph/nodes/intake.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChannelContextResult and retriever types</name>
  <files>src/context/retriever.py</files>
  <action>
Create src/context/retriever.py with result types:

```python
"""Channel context retrieval for agent consumption."""
import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Optional, Literal

from psycopg import AsyncConnection

from src.db.channel_context_store import ChannelContextStore
from src.db.models import ChannelContext
from src.config.settings import get_settings

logger = logging.getLogger(__name__)


class RetrievalMode(str, Enum):
    """Context retrieval modes."""
    COMPACT = "compact"  # 10-20 bullets, production use
    DEBUG = "debug"      # Full details, troubleshooting
    RAW = "raw"          # Internal use, full model


@dataclass
class ContextSource:
    """Tracks where a piece of context came from."""
    layer: Literal["knowledge", "jira", "config", "derived"]
    source_id: str  # pin_id, jira_key, etc.
    source_type: str  # "pin", "epic", "ticket", "config"


@dataclass
class ChannelContextResult:
    """Result of context retrieval for agent consumption.

    Designed for injection into AgentState.
    """
    channel_id: str
    team_id: str

    # Version for cache invalidation
    context_version: int

    # Compact representation (bullets)
    bullets: list[str] = field(default_factory=list)

    # Key facts
    default_project: Optional[str] = None
    naming_convention: Optional[str] = None
    definition_of_done: Optional[str] = None

    # Active context
    active_epics: list[str] = field(default_factory=list)
    recent_tickets: list[str] = field(default_factory=list)

    # Source tracking (for explainability)
    sources: list[ContextSource] = field(default_factory=list)

    # Metadata
    retrieved_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    mode: RetrievalMode = RetrievalMode.COMPACT

    def to_dict(self) -> dict:
        """Convert to dict for AgentState storage."""
        return {
            "channel_id": self.channel_id,
            "team_id": self.team_id,
            "context_version": self.context_version,
            "bullets": self.bullets,
            "default_project": self.default_project,
            "naming_convention": self.naming_convention,
            "definition_of_done": self.definition_of_done,
            "active_epics": self.active_epics,
            "recent_tickets": self.recent_tickets,
            "retrieved_at": self.retrieved_at.isoformat(),
            "mode": self.mode.value,
        }
```
  </action>
  <verify>python -c "from src.context.retriever import ChannelContextResult, RetrievalMode, ContextSource; print('ok')"</verify>
  <done>ChannelContextResult and supporting types defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement ChannelContextRetriever</name>
  <files>src/context/retriever.py</files>
  <action>
Add ChannelContextRetriever class to retriever.py:

```python
class ChannelContextRetriever:
    """Retrieves and compresses channel context for agent consumption.

    Usage:
        async with get_connection() as conn:
            retriever = ChannelContextRetriever(conn)
            result = await retriever.get_context(team_id, channel_id, mode="compact")
    """

    def __init__(self, conn: AsyncConnection) -> None:
        self._conn = conn
        self._store = ChannelContextStore(conn)

    async def get_context(
        self,
        team_id: str,
        channel_id: str,
        mode: RetrievalMode = RetrievalMode.COMPACT,
    ) -> ChannelContextResult:
        """Get channel context in specified mode.

        Args:
            team_id: Slack team ID.
            channel_id: Slack channel ID.
            mode: Retrieval mode (compact, debug, raw).

        Returns:
            ChannelContextResult with compressed context.
        """
        ctx = await self._store.get_by_channel(team_id, channel_id)

        if not ctx:
            # Return empty context for new channels
            return ChannelContextResult(
                channel_id=channel_id,
                team_id=team_id,
                context_version=0,
                mode=mode,
            )

        if mode == RetrievalMode.RAW:
            return self._to_raw_result(ctx)
        elif mode == RetrievalMode.DEBUG:
            return self._to_debug_result(ctx)
        else:
            return self._to_compact_result(ctx)

    def _to_compact_result(self, ctx: ChannelContext) -> ChannelContextResult:
        """Convert to compact mode (10-20 bullets max)."""
        settings = get_settings()
        max_bullets = settings.channel_context_max_bullets

        bullets = []
        sources = []

        # Layer 1: Config (defaults)
        if ctx.config.default_jira_project:
            bullets.append(f"Default project: {ctx.config.default_jira_project}")
            sources.append(ContextSource("config", "default_project", "config"))

        # Layer 2: Knowledge (facts from pins)
        if ctx.knowledge.naming_convention:
            bullets.append(f"Naming: {ctx.knowledge.naming_convention[:80]}")
            sources.append(ContextSource("knowledge", ctx.knowledge.source_pin_ids[0] if ctx.knowledge.source_pin_ids else "", "pin"))

        if ctx.knowledge.definition_of_done:
            bullets.append(f"DoD: {ctx.knowledge.definition_of_done[:80]}")

        if ctx.knowledge.api_format_rules:
            bullets.append(f"API rules: {ctx.knowledge.api_format_rules[:60]}")

        # Custom rules (max 3)
        for name, rule in list(ctx.knowledge.custom_rules.items())[:3]:
            bullets.append(f"{name}: {rule[:50]}")

        # Layer 3: Activity
        if ctx.activity.active_epics:
            epics_str = ", ".join(ctx.activity.active_epics[:5])
            bullets.append(f"Active epics: {epics_str}")
            for epic in ctx.activity.active_epics[:5]:
                sources.append(ContextSource("jira", epic, "epic"))

        if ctx.activity.recent_tickets:
            tickets_str = ", ".join(ctx.activity.recent_tickets[:5])
            bullets.append(f"Recent tickets: {tickets_str}")

        # Truncate to max
        bullets = bullets[:max_bullets]

        return ChannelContextResult(
            channel_id=ctx.channel_id,
            team_id=ctx.team_id,
            context_version=ctx.version,
            bullets=bullets,
            default_project=ctx.config.default_jira_project,
            naming_convention=ctx.knowledge.naming_convention,
            definition_of_done=ctx.knowledge.definition_of_done,
            active_epics=ctx.activity.active_epics[:10],
            recent_tickets=ctx.activity.recent_tickets[:10],
            sources=sources,
            mode=RetrievalMode.COMPACT,
        )

    def _to_debug_result(self, ctx: ChannelContext) -> ChannelContextResult:
        """Convert to debug mode (full details)."""
        result = self._to_compact_result(ctx)
        result.mode = RetrievalMode.DEBUG

        # Add all bullets without truncation
        result.bullets = []

        # Full config
        result.bullets.append(f"[CONFIG] default_project: {ctx.config.default_jira_project}")
        result.bullets.append(f"[CONFIG] trigger_rule: {ctx.config.trigger_rule}")
        result.bullets.append(f"[CONFIG] epic_binding: {ctx.config.epic_binding_behavior}")

        # Full knowledge
        if ctx.knowledge.naming_convention:
            result.bullets.append(f"[KNOWLEDGE] naming: {ctx.knowledge.naming_convention}")
        if ctx.knowledge.definition_of_done:
            result.bullets.append(f"[KNOWLEDGE] DoD: {ctx.knowledge.definition_of_done}")
        if ctx.knowledge.api_format_rules:
            result.bullets.append(f"[KNOWLEDGE] API: {ctx.knowledge.api_format_rules}")
        for name, rule in ctx.knowledge.custom_rules.items():
            result.bullets.append(f"[KNOWLEDGE] {name}: {rule}")

        # Full activity
        result.bullets.append(f"[ACTIVITY] epics: {ctx.activity.active_epics}")
        result.bullets.append(f"[ACTIVITY] tickets: {ctx.activity.recent_tickets}")

        # Metadata
        result.bullets.append(f"[META] version: {ctx.version}")
        result.bullets.append(f"[META] pinned_digest: {ctx.pinned_digest}")
        result.bullets.append(f"[META] updated_at: {ctx.updated_at}")

        return result

    def _to_raw_result(self, ctx: ChannelContext) -> ChannelContextResult:
        """Convert to raw mode (for internal use)."""
        result = self._to_debug_result(ctx)
        result.mode = RetrievalMode.RAW
        return result
```
  </action>
  <verify>python -c "from src.context.retriever import ChannelContextRetriever; print('ok')"</verify>
  <done>ChannelContextRetriever with compact, debug, raw modes</done>
</task>

<task type="auto">
  <name>Task 3: Add channel_context to AgentState</name>
  <files>src/schemas/state.py</files>
  <action>
Update AgentState in src/schemas/state.py to include channel_context field:

1. Add to imports (if not present):
```python
from typing import Literal, Optional, Annotated, Any, TYPE_CHECKING
```

2. Add field to AgentState TypedDict (after channel_id field):

```python
    # Channel context (Phase 8 - Global State)
    channel_context: Optional[dict[str, Any]]  # ChannelContextResult.to_dict()
```

Place this after the `channel_id` field and before `user_id`.
  </action>
  <verify>python -c "from src.schemas.state import AgentState; print('channel_context' in AgentState.__annotations__)"</verify>
  <done>AgentState has channel_context field</done>
</task>

<task type="auto">
  <name>Task 4: Inject context in intake node</name>
  <files>src/graph/nodes/intake.py</files>
  <action>
Update intake node to inject channel context on new thread.

Add context injection at the start of the intake node (after getting channel_id from state):

```python
# Inject channel context if not already present
if state.get("channel_context") is None and state.get("channel_id"):
    try:
        from src.context.retriever import ChannelContextRetriever, RetrievalMode
        from src.db.connection import get_connection

        async with get_connection() as conn:
            retriever = ChannelContextRetriever(conn)
            team_id = state.get("team_id", "default")  # Get from session if available
            ctx_result = await retriever.get_context(
                team_id=team_id,
                channel_id=state["channel_id"],
                mode=RetrievalMode.COMPACT,
            )
            state["channel_context"] = ctx_result.to_dict()
            logger.debug(f"Injected channel context v{ctx_result.context_version}")
    except Exception as e:
        logger.warning(f"Failed to inject channel context: {e}")
        # Non-blocking - continue without context
```

This should be early in the node, before any extraction or validation logic.
  </action>
  <verify>python -c "from src.graph.nodes.intake import intake_node; print('ok')"</verify>
  <done>Intake node injects channel context on new thread</done>
</task>

<task type="auto">
  <name>Task 5: Update context package exports</name>
  <files>src/context/__init__.py</files>
  <action>
Update src/context/__init__.py to export all context components:

```python
"""Channel context management for global state."""
from src.context.pin_extractor import PinExtractor, PinInfo
from src.context.root_indexer import RootIndexer
from src.context.jira_linker import JiraLinker, ThreadJiraLink
from src.context.retriever import (
    ChannelContextRetriever,
    ChannelContextResult,
    RetrievalMode,
    ContextSource,
)

__all__ = [
    "PinExtractor",
    "PinInfo",
    "RootIndexer",
    "JiraLinker",
    "ThreadJiraLink",
    "ChannelContextRetriever",
    "ChannelContextResult",
    "RetrievalMode",
    "ContextSource",
]
```
  </action>
  <verify>python -c "from src.context import ChannelContextRetriever, ChannelContextResult, RetrievalMode; print('ok')"</verify>
  <done>All context components exported from package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.context.retriever import ChannelContextRetriever, ChannelContextResult"` succeeds
- [ ] `python -c "from src.context import ChannelContextRetriever"` succeeds
- [ ] AgentState has channel_context field
- [ ] Intake node injects context on new thread
- [ ] Compact mode produces max 15 bullets
</verification>

<success_criteria>

- ChannelContextRetriever with compact (default), debug, raw modes
- ChannelContextResult with bullets, sources, version
- AgentState includes channel_context field
- Context injected on new thread in intake node
- Graceful degradation if context fetch fails
- All exports configured in src/context/__init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/08-global-state/08-05-SUMMARY.md`
</output>
